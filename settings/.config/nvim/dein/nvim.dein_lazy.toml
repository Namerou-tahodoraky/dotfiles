# ---------------------------------------------------------------------------------------------
# プラットフォーム系ツール.
# 他ツールが動作する為の依存関係.
# ---------------------------------------------------------------------------------------------

# Deno依存のプラグインを動作させる
[[plugins]]
repo = 'vim-denops/denops.vim'


# ---------------------------------------------------------------------------------------------
# ファイル/テキスト編集補助ツール.
# ---------------------------------------------------------------------------------------------

[[plugins]]
# treesitterを利用した自動インデントプラグイン.
# treesitterや別プラグインだとバグや誤動作がちょくちょくある.
repo = 'yioneko/nvim-yati'
on_source = 'nvim-treesitter'
hook_source = '''
lua <<EOF
require("nvim-treesitter.configs").setup {
  yati = { enable = true },
}
EOF
'''

# [[plugins]] # TODO: 全然使ってないので一時的に削除. 使うのか再考する.
# # プロジェクト内のファイルの一斉置換
# repo ='nvim-pack/nvim-spectre'
# depends = ['plenary.nvim']
# # on_source = 'nvim-lspconfig'
# on_event = 'BufRead'
# hook_source = '''
# lua << EOF
# require('spectre').setup()
# EOF
# '''
# hook_add = '''
# nnoremap <leader>R :lua require('spectre').open()<CR>
# "search current word
# nnoremap <leader>rw :lua require('spectre').open_visual({select_word=true})<CR>
# vnoremap <leader>r :lua require('spectre').open_visual()<CR>
# "  search in current file
# nnoremap <leader>rp viw:lua require('spectre').open_file_search()<cr>
# '''


# ---------------------------------------------------------------------------------------------
# カーソル移動補助ツール.
# ---------------------------------------------------------------------------------------------

[[plugins]]
# 移動補助
# /や?で検索した時検索先にeasymotionのような移動キーが表示される
repo = 'hrsh7th/vim-searchx'
hook_add = '''
" nnoremap <Leader>? <Cmd>call searchx#start({ 'dir': 0 })<CR>
" xnoremap <Leader>? <Cmd>call searchx#start({ 'dir': 0 })<CR>
nnoremap <Leader>/ <Cmd>call searchx#start({ 'dir': 1 })<CR>
xnoremap <Leader>/ <Cmd>call searchx#start({ 'dir': 1 })<CR>
" cnoremap <Leader>; <Cmd>call searchx#select()<CR>

" " Move to next/prev match.
" nnoremap N <Cmd>call searchx#prev_dir()<CR>
" nnoremap n <Cmd>call searchx#next_dir()<CR>
" xnoremap N <Cmd>call searchx#prev_dir()<CR>
" xnoremap n <Cmd>call searchx#next_dir()<CR>
" nnoremap <C-k> <Cmd>call searchx#prev()<CR>
" nnoremap <C-j> <Cmd>call searchx#next()<CR>
" xnoremap <C-k> <Cmd>call searchx#prev()<CR>
" xnoremap <C-j> <Cmd>call searchx#next()<CR>
" cnoremap <C-k> <Cmd>call searchx#prev()<CR>
" cnoremap <C-j> <Cmd>call searchx#next()<CR>

" Clear highlights
nnoremap <C-l> <Cmd>call searchx#clear()<CR>

let g:searchx = {}

" Auto jump if the recent input matches to any marker.
let g:searchx.auto_accept = v:true

" The scrolloff value for moving to next/prev.
let g:searchx.scrolloff = &scrolloff

" To enable scrolling animation.
" let g:searchx.scrolltime = 500
let g:searchx.scrolltime = 0

" Marker characters.
let g:searchx.markers = split('ABCDEFGHIJKLMNOPQRSTUVWXYZ', '.\zs')

" Convert search pattern.
function g:searchx.convert(input) abort
  if a:input !~# '\k'
    return '\V' .. a:input
  endif
  return a:input[0] .. substitute(a:input[1:], '\\\@<! ', '.\\{-}', 'g')
endfunction
'''

[[plugins]]
# スムーズスクロール
repo = 'karb94/neoscroll.nvim'
on_event = 'BufEnter'
hook_source = '''
lua <<EOF
require('neoscroll').setup({
    mappings = {'<C-u>', '<C-d>', '<C-y>', '<C-e>'},
})
-- require('neoscroll').setup()
EOF
'''

# [[plugins]] # エラーが出て何個目かの情報が表示されない. # TODO: 調査.
# # 検索にヒットしたものが何個中何個目かをvertualtextで表示する
# repo = 'kevinhwang91/nvim-hlslens'
# on_event = 'BufEnter'
# hook_add = '''
# noremap <silent> n <Cmd>execute('normal! ' . v:count1 . 'n')<CR>
#             \<Cmd>lua require('hlslens').start()<CR>
# noremap <silent> N <Cmd>execute('normal! ' . v:count1 . 'N')<CR>
#             \<Cmd>lua require('hlslens').start()<CR>
# '''
# # hook_source = '''
# # lua << EOF
# # require('hlslens').setup()
# # 
# # local kopts = {noremap = true, silent = true}
# # 
# # vim.api.nvim_set_keymap('n', 'n',
# #     [[<Cmd>execute('normal! ' . v:count1 . 'n')<CR><Cmd>lua require('hlslens').start()<CR>]],
# #         kopts)
# # vim.api.nvim_set_keymap('n', 'N',
# #     [[<Cmd>execute('normal! ' . v:count1 . 'N')<CR><Cmd>lua require('hlslens').start()<CR>]],
# #         kopts)
# # vim.api.nvim_set_keymap('n', '*', [[*<Cmd>lua require('hlslens').start()<CR>]], kopts)
# # vim.api.nvim_set_keymap('n', '#', [[#<Cmd>lua require('hlslens').start()<CR>]], kopts)
# # vim.api.nvim_set_keymap('n', 'g*', [[g*<Cmd>lua require('hlslens').start()<CR>]], kopts)
# # vim.api.nvim_set_keymap('n', 'g#', [[g#<Cmd>lua require('hlslens').start()<CR>]], kopts)
# # EOF
# # '''

[[plugins]] # nvim-hlslensを一旦消したのでこっちも合わせて消しておく # TODO: 戻す.
# 検索時に勝手にカーソルが移動するのを防ぐ.
# 選択範囲の文字列でアスタリスク検索する機能ももつ.
# キーマップにvim-asteriskとnvim-hlslensの機能両方を結びつける為に、nvim-hlslensをdependsにしている.
repo = 'haya14busa/vim-asterisk'
# depends = ['nvim-hlslens']
# # on_source = 'nvim-hlslens'
# hook_add = '''
# map * <Plug>(asterisk-z*)<Cmd>lua require('hlslens').start()<CR>
# map # <Plug>(asterisk-z#)<Cmd>lua require('hlslens').start()<CR>
# map g* <Plug>(asterisk-gz*)<Cmd>lua require('hlslens').start()<CR>
# map g# <Plug>(asterisk-gz#)<Cmd>lua require('hlslens').start()<CR>
# let g:asterisk#keeppos = 1
# # '''
on_event = 'BufEnter'
hook_add = '''
map * <Plug>(asterisk-z*)
map # <Plug>(asterisk-z#)
map g* <Plug>(asterisk-gz*)
map g# <Plug>(asterisk-gz#)
let g:asterisk#keeppos = 1
'''

# ---------------------------------------------------------------------------------------------
# プログラミング補助.
# LSPセットアップ.
# ---------------------------------------------------------------------------------------------

[[plugins]]
repo = 'neovim/nvim-lspconfig'
# on_event = 'BufEnter'
# depends = ["ddc-nvim-lsp-setup"]
on_source = ["ddc-nvim-lsp-setup"]
hook_source = '''
lua << EOF

-- -- これつけるとyamllsが動かない.
-- -- nvim-lsp.yamlls.setup {
-- --   settings = {
-- --     yaml = {
-- --       schemas = require('schemastore').yaml.schemas {
-- --        select = {
-- --          'docker-compose.yml',
-- --        },
-- --      },
-- --     },
-- --   },
-- -- }
-- 
-- require'lspconfig'.yamlls.setup{
--    cmd = {"~/.local/share/nvim/lsp_servers/yaml/node_modules/.bin/yaml-language-server", "--stdio"},
--    -- on_attach = require'lsp'.common_on_attach,
--    settings = {
--        yaml = {
--            format = {
--                    enable = true,
--            },
--            hover = true,
--            completion = true,
-- 
--            customTags = {
--                "!fn",
--                "!And",
--                "!If",
--                "!Not",
--                "!Equals",
--                "!Or",
--                "!FindInMap sequence",
--                "!Base64",
--                "!Cidr",
--                "!Ref",
--                "!Ref Scalar",
--                "!Sub",
--                "!GetAtt",
--                "!GetAZs",
--                "!ImportValue",
--                "!Select",
--                "!Split",
--                "!Join sequence"
--            },
--        },
--    },
--  }

EOF
'''

[[plugins]]
# mason.nvimでインストールしたプラグインをnvim-lspconfigの設定に流す橋渡し役.
# mason.nvimで認識されるプラグイン名とnvim-lspconfigで認識されるLaunguage Server名が異なっていることがあったり、そういう設定の面倒事を吸収している.
# nvim-lspconfigにかける設定項目もこちらに書く方が無難か.
repo ='williamboman/mason-lspconfig.nvim'
on_source = ['nvim-lspconfig', "masson.nvim"]
hook_source = '''
lua << EOF
require("mason-lspconfig").setup()
require("mason-lspconfig").setup_handlers {
  function(server_name) -- default handler (optional)
    require("lspconfig")[server_name].setup {
      -- on_attach = on_attach,
      on_attach = function (client, bufnr)
        local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end
        local function buf_set_option(...) vim.api.nvim_buf_set_option(bufnr, ...) end

        local opts = { noremap=true, silent=true }
        buf_set_keymap('n', 'gd', '<Cmd>lua vim.lsp.buf.definition()<CR>', opts)
        buf_set_keymap('n', 'gK', '<Cmd>lua vim.lsp.buf.hover()<CR>', opts)
        buf_set_keymap('n', 'gi', '<cmd>lua vim.lsp.buf.implementation()<CR>', opts)
        buf_set_keymap('n', 'gs', '<cmd>lua vim.lsp.buf.signature_help()<CR>', opts)
        buf_set_keymap('n', 'gr', '<cmd>lua vim.lsp.buf.references()<CR>', opts)
        buf_set_keymap('n', 'gx', '<cmd>lua vim.diagnostic.open_float(0, {scope="line"})<CR>', opts)
        buf_set_keymap('n', 'g[', '<cmd>lua vim.diagnostic.goto_prev({float={...}})<CR>', opts)
        buf_set_keymap('n', 'g]', '<cmd>lua vim.diagnostic.goto_next({float={...}})<CR>', opts)
      end
    }
  end
}

-- # ---------------------------------------------------------------------------------------------
-- # ruffと重複しているpylspのリントを消す.
-- # ---------------------------------------------------------------------------------------------
require("lspconfig").pylsp.setup {
-- local servers = {
--   pylsp = {
--     cmd = {"pylsp"},
--     root_dir = function(fname)
--       local root_files = {
--         'pyproject.toml',
--         'setup.py',
--         'setup.cfg',
--         'requirements.txt',
--         'Pipfile',
--       }
--       return util.root_pattern(unpack(root_files))(fname) or util.find_git_ancestor(fname)
--     end,
  settings = {
    pylsp = {
      -- configurationSources = {"pylint"},
      plugins = {
        autpep8 = { enabled = false },
        pylint = { enabled = false },
        flake8 = { enabled = false },
        pycodestyle = { enabled = false },
        pyflakes = { enabled = false },
      }
    }
  }
--  }
-- }
}

-- # ---------------------------------------------------------------------------------------------
-- # diagnosticのエディタ画面への描画設定.
-- # ---------------------------------------------------------------------------------------------
vim.lsp.handlers["textDocument/publishDiagnostics"] = vim.lsp.with(
  vim.lsp.diagnostic.on_publish_diagnostics, {
    -- -- Enable underline, use default values
    -- underline = true,
    underline = false,
    -- -- Enable virtual text, override spacing to 4
    -- virtual_text = {
    --   spacing = 4,
    -- },
    virtual_text = true,
    -- Use a function to dynamically turn signs off
    -- and on, using buffer local variables
    -- signs = function(bufnr, client_id)
    --   return vim.bo[bufnr].show_signs == false
    -- end,
    signs = true,
    -- -- Disable a feature
    update_in_insert = false,
  }
)


EOF
'''


# ---------------------------------------------------------------------------------------------
# プログラミング補助.
# 自動補完などの入力補助系.
# ---------------------------------------------------------------------------------------------

# 入力に対応して様々な補完候補を集約してポップアップする.
# 補完候補を生成するのはsource用プラグインの役割.
[[plugins]]
repo = 'Shougo/ddc.vim'
# on_event = 'InsertEnter'
on_event = 'BufEnter'
depends = ['denops.vim']
hook_source = '''
call ddc#custom#patch_global('sources', ['nvim-lsp', 'around', 'file'])
call ddc#custom#patch_global('ui', 'pum')
call ddc#custom#patch_global('sourceOptions', {
     \ '_': {
     \   'matchers': ['matcher_fuzzy'],
     \   'sorters': ['sorter_fuzzy'],
     \   'converters': ['converter_fuzzy'],
     \ },
     \ 'around': {'mark': 'AROUND'},
     \ 'file': {'mark': 'FILE'},
     \ 'nvim-lsp': {
     \   'mark': 'LSP',
     \   'dup': 'keep',
     \   'keywordPattern': '\k+',
     \   'sorters': ['sorter_lsp-kind']
     \ },
\})

call ddc#custom#patch_global('sourceParams', {
\  'around': {'maxSize': 500},
\  'nvim-lsp': {
\    'snippetEngine': denops#callback#register({
\          body -> vsnip#anonymous(body) }),
\    'enableResolveItem': v:true,
\    'enableAdditionalTextEdit': v:true,
\    'confirmBehavior': 'replace',
\  },
\})

call ddc#enable()
'''
# # LSPの補完開始を遅くする設定(主にTerraformのresource補完用)
# hook_add = '''
# nnoremap <silent> gcl :call ddc#custom#patch_global('sourceOptions', {'nvim-lsp': {'minAutoCompleteLength': 5}})<CR>
# nnoremap <silent> gcs :call ddc#custom#patch_global('sourceOptions', {'nvim-lsp': {'minAutoCompleteLength': 1}})<CR>

[[plugins]]
repo = 'Shougo/ddc-ui-pum'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-source-nvim-lsp'
on_source = 'ddc.vim'

[[plugins]]
repo = 'uga-rosa/ddc-nvim-lsp-setup'
on_source = 'ddc.vim'
hook_source = '''
lua << EOF
require("ddc_nvim_lsp_setup").setup()
EOF
'''

[[plugins]]
repo = 'tani/ddc-fuzzy'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-source-around'
on_source = 'ddc.vim'

# ファイル名を補完するsource
[[plugins]]
repo = 'LumaKernel/ddc-source-file'
on_source = 'ddc.vim'

# ポップアップウィンドウを表示するプラグイン
[[plugins]]
repo = 'Shougo/pum.vim'
# on_source = 'ddc.vim'
# depends = ['vim-vsnip-integ']
# <Tab>と<S-Tab>が何故か効かないのでいっそのことコメントアウトしている.
hook_add = '''
" "inoremap <Tab> <Cmd>call pum#map#insert_relative(+1)<CR>
" "inoremap <S-Tab> <Cmd>call pum#map#insert_relative(-1)<CR>
" "inoremap <silent><expr> <TAB>
" "     \ pum#visible() ? '<Cmd>call pum#map#insert_relative(+1)<CR>' :
" "     \ (col('.') <= 1 <Bar><Bar> getline('.')[col('.') - 2] =~# '\s') ?
" "     \ '<TAB>' : ddc#manual_complete()
" "inoremap <S-Tab> <Cmd>call pum#map#insert_relative(-1)<CR>
inoremap <C-n>   <Cmd>call pum#map#insert_relative(+1)<CR>
inoremap <C-p>   <Cmd>call pum#map#insert_relative(-1)<CR>

" autocmd User PumCompleteDone call vsnip_integ#on_complete_done(g:pum#completed_item)
'''



# # [[plugins]] # TODO: 削除する.
# # # インストール済みのlinterやforatterを呼び出しての出力結果をLSPに渡す
# # repo ='jose-elias-alvarez/null-ls.nvim'
# # depends = ['plenary.nvim']
# # on_source = 'nvim-lspconfig'
# # hook_source = '''
# # lua << EOF
# # require("null-ls").setup({
# #     sources = {
# #         -- require("null-ls").builtins.completion.spell,
# #         require("null-ls").builtins.diagnostics.flake8,
# #         require("null-ls").builtins.diagnostics.mypy,
# #         require("null-ls").builtins.diagnostics.shellcheck,
# #         require("null-ls").builtins.diagnostics.cfn_lint,
# #         require("null-ls").builtins.formatting.ruff,
# #         require("null-ls").builtins.diagnostics.ruff,
# #         -- require("null-ls").builtins.diagnostics.mypy.with({
# #         --     command = "pipenv run mypy",
# #         -- }),
# #     }
# # })
# # EOF
# # '''

# [[plugins]]
# # LSPの動作待ち中プログレスバーを表示する.
# # pylspはおそらく対応していない. -> pyrightが対応しているっぽい.
# # null-lsは対応している.
# # terraform-lsはおそらく対応している.
# 下記エラーが表示されるようになったのでとりあえず外した. # TODO: 要調査
# fidget.nvim will soon be rewritten. Please checkout the 'legacy' tag to avoid breaking changes
# repo = 'j-hui/fidget.nvim'
# on_event = 'BufEnter'
# hook_source = '''
# lua require"fidget".setup{}
# '''

# ddcの候補選択中にシグネイチャーとドキュメントをポップアップする.
[[plugins]]
repo = 'matsui54/denops-popup-preview.vim'
on_source = 'ddc.vim'
depends = ['denops.vim']
hook_source = '''
call popup_preview#enable()
'''

# 関数の()内入力中にシグネイチャーをポップアップする.
# ddcやdenops-popup-preview.vimとは独立して動く.
[[plugins]]
repo = 'ray-x/lsp_signature.nvim'
on_event = 'BufRead'
hook_source = '''
lua << EOF
require("lsp_signature").setup()
EOF
 '''

[[plugins]]
# diagnosticsの一覧を表示する.diagnosticsの発生個所に飛べる.
# 一覧にカーソルを合わせるだけで発生個所が表示されるので、
# LSPのショートカットキーで一つずつ飛ぶより楽.
# 実行コマンド :TroubleToggle
# 実行コマンド :TroubleRefresh
repo = 'folke/trouble.nvim'
depends = ['nvim-web-devicons']
on_event = 'BufRead'
hook_source = '''
lua << EOF
require("trouble").setup {}
-- vim.keymap.set("n", "<leader>gxd", function() require("trouble").toggle("document_diagnostics") end)
vim.keymap.set("n", "gX", function() require("trouble").toggle("workspace_diagnostics") end)
EOF
'''


# [[plugins]] # TODO: 更新対応.
#  repo = 'hrsh7th/vim-vsnip'
#  on_event = 'InsertEnter'
#  depends = ['vim-vsnip-integ']
#  hook_add = '''
#  " Expand
#  imap <expr> <C-j>   vsnip#expandable()  ? '<Plug>(vsnip-expand)'         : '<C-j>'
#  smap <expr> <C-j>   vsnip#expandable()  ? '<Plug>(vsnip-expand)'         : '<C-j>'
#  
#  " Expand or jump
#  imap <expr> <C-l>   vsnip#available(1)  ? '<Plug>(vsnip-expand-or-jump)' : '<C-l>'
#  smap <expr> <C-l>   vsnip#available(1)  ? '<Plug>(vsnip-expand-or-jump)' : '<C-l>'
#  
#  " Jump forward or backward
#  imap <expr> <Tab>   vsnip#jumpable(1)   ? '<Plug>(vsnip-jump-next)'      : '<Tab>'
#  smap <expr> <Tab>   vsnip#jumpable(1)   ? '<Plug>(vsnip-jump-next)'      : '<Tab>'
#  imap <expr> <S-Tab> vsnip#jumpable(-1)  ? '<Plug>(vsnip-jump-prev)'      : '<S-Tab>'
#  smap <expr> <S-Tab> vsnip#jumpable(-1)  ? '<Plug>(vsnip-jump-prev)'      : '<S-Tab>'
#  
#  " " Select or cut text to use as $TM_SELECTED_TEXT in the next snippet.
#  " " See https://github.com/hrsh7th/vim-vsnip/pull/50
#  " nmap        s   <Plug>(vsnip-select-text)
#  " xmap        s   <Plug>(vsnip-select-text)
#  " nmap        S   <Plug>(vsnip-cut-text)
#  " xmap        S   <Plug>(vsnip-cut-text)
#  
#  " If you want to use snippet for multiple filetypes, you can `g:vsnip_filetypes` for it.
#  let g:vsnip_filetypes = {}
#  let g:vsnip_filetypes.python = ['python']
#  " let g:vsnip_filetypes.javascriptreact = ['javascript']
#  " let g:vsnip_filetypes.typescriptreact = ['typescript']
# 
#  " let g:vsnip_snippet_dir = expand('~/.config/nvim/vsnips')
#  let g:vsnip_snippet_dirs = []
#  let g:vsnip_snippet_dirs += ['~/.config/nvim/vsnips/python']
#  let g:vsnip_snippet_dirs += ['~/.config/nvim/vsnips/python/pytest']
#  let g:vsnip_snippet_dirs += ['~/.config/nvim/vsnips/terraform']
#  '''
# 
# [[plugins]]
#  repo = 'hrsh7th/vim-vsnip-integ'


# # ---------------------------------------------------------------------------------------------
# # デバッグツール.
# # ---------------------------------------------------------------------------------------------
# [[plugins]]
# # デバッグツール
# # ステップイン: 1行進む.
# # ステップオーバー: 1行進む.進み先が関数内に入る場合は、関数内はスキップする.
# # ステップアウト: そのスコープを出るまで進む.
# repo = 'mfussenegger/nvim-dap'
# on_ft = ['python']
# hook_add = '''
# nnoremap <silent> <Leader>0 :lua require'dap'.continue()<CR>
# nnoremap <silent> <Leader>1 :lua require'dap'.step_into()<CR>
# nnoremap <silent> <Leader>2 :lua require'dap'.step_over()<CR>
# nnoremap <silent> <Leader>3 :lua require'dap'.step_out()<CR>
# nnoremap <silent> <leader>dq :lua require'dap'.terminate(); require'dapui'.close()<CR>
# nnoremap <silent> <leader>db :lua require'dap'.toggle_breakpoint()<CR>
# nnoremap <silent> <leader>dc :lua require'dap'.set_breakpoint(vim.fn.input('Breakpoint condition: '))<CR>
# nnoremap <silent> <leader>dB :lua require'dap'.clear_breakpoints()<CR>
# " nnoremap <silent> <leader>dp :lua require'dap'.set_breakpoint(nil, nil, vim.fn.input('Log point message: '))<CR>
# " nnoremap <silent> <leader>dr :lua require'dap'.repl.open()<CR>
# '''
# 
# [[plugins]]
# # 
# repo = 'mfussenegger/nvim-dap-python'
# depends = ['nvim-dap']
# on_ft = 'python'
# hook_source = '''
# lua << EOF
# pythonPath = function()
#   -- debugpy supports launching an application with a different interpreter then the one used to launch debugpy itself.
#   -- The code below looks for a `venv` or `.venv` folder in the current directly and uses the python within.
#   -- You could adapt this - to for example use the `VIRTUAL_ENV` environment variable.
#   local cwd = vim.fn.getcwd()
#   if vim.fn.executable(cwd .. '/venv/bin/python') == 1 then
#     return cwd .. '/venv/bin/python'
#   elseif vim.fn.executable(cwd .. '/.venv/bin/python') == 1 then
#     return cwd .. '/.venv/bin/python'
#   else
#     return '/usr/bin/python'
#   end
# end;
# 
# require('dap-python').setup(pythonPath())
# require('dap-python').test_runner = 'pytest'
# EOF
# '''
# 
# [[plugins]]
# # デバッグツール
# # デバッグ画面
# repo = 'rcarriga/nvim-dap-ui'
# # depends = ['nvim-dap']
# # on_ft = ['python']
# on_source = ['nvim-dap']
# hook_source = '''
# lua << EOF
# require('dapui').setup()
# 
# -- デバッグ開始時に自動でUI画面を開く.
# require'dap'.listeners.before['event_initialized']['custom'] = function(session, body)
#   require'dapui'.open()
# end
# -- デバッグ終了時に自動でUI画面を閉じる.
# require'dap'.listeners.before['event_terminated']['custom'] = function(session, body)
#   require'dapui'.close()
# end
# EOF
# '''
# 
# [[plugins]]
# # デバッグツール
# # 変数の値をvertualtextで表示する
# repo = 'theHamsta/nvim-dap-virtual-text'
# # depends = ['nvim-dap']
# on_ft = ['python']
# hook_source = '''
# lua << EOF
# -- require("nvim-dap-virtual-text").setup()
# require("nvim-dap-virtual-text").setup {
#     enabled = true,                     -- enable this plugin (the default)
#     enabled_commands = true,            -- create commands DapVirtualTextEnable, DapVirtualTextDisable, DapVirtualTextToggle, (DapVirtualTextForceRefresh for refreshing when debug adapter did not notify its termination)
#     highlight_changed_variables = false, -- highlight changed values with NvimDapVirtualTextChanged, else always NvimDapVirtualText
#     highlight_new_as_changed = false,   -- highlight new variables in the same way as changed variables (if highlight_changed_variables)
#     show_stop_reason = true,            -- show stop reason when stopped for exceptions
#     commented = false,                  -- prefix virtual text with comment string
#     -- experimental features:
#     virt_text_pos = 'eol',              -- position of virtual text, see `:h nvim_buf_set_extmark()`
#     all_frames = false,                 -- show virtual text for all stack frames not only current. Only works for debugpy on my machine.
#     virt_lines = false,                 -- show virtual lines instead of virtual text (will flicker!)
#     virt_text_win_col = nil             -- position the virtual text at a fixed window column (starting from the first text column) ,
#                                         -- e.g. 80 to position at column 80, see `:h nvim_buf_set_extmark()`
# }
# EOF
# '''

# ---------------------------------------------------------------------------------------------
# カスタマイズ設定の索引ツール.
# ---------------------------------------------------------------------------------------------

[[plugins]]
# キーバインドを通知
repo = 'liuchengxu/vim-which-key'
hook_add = '''
nnoremap <silent> <leader> :WhichKey '<Space>'<CR>
'''


# # ---------------------------------------------------------------------------------------------
# # 画面描画ツール(色, アイコン,ステータスラインなど)
# # ---------------------------------------------------------------------------------------------

[[plugins]]
repo = 'nvim-treesitter/nvim-treesitter'
if = 'has("nvim")'
on_event = 'BufRead'
hook_post_update = 'TSUpdate'
hook_source = '''
lua <<EOF
require'nvim-treesitter.configs'.setup {
    -- ensure_installed = 'all',
    highlight = {
        enable = true,
        disable = {},
    },
    -- 編集中に動くのが気持ち悪い.挙動が予測しにくい.
    -- indent = {
    --     enable = true,
    -- },
}
EOF
'''

# [[plugins]] # 少し使ってみたけど余り目に馴染まないから消した. # TODO: 削除検討.
# repo = 'p00f/nvim-ts-rainbow'
# on_source = 'nvim-treesitter'
# hook_source = '''
# lua <<EOF
# require("nvim-treesitter.configs").setup {
#   -- highlight = {
#   --     -- ...
#   -- },
#   -- -- ...
#   rainbow = {
#     enable = true,
#     -- disable = { "jsx", "cpp" }, list of languages you want to disable the plugin for
#     extended_mode = true, -- Also highlight non-bracket delimiters like html tags, boolean or table: lang -> boolean
#     max_file_lines = nil, -- Do not enable for files with more than n lines, int
#     -- colors = {}, -- table of hex strings
#     -- termcolors = {} -- table of colour name strings
#   }
# }
# EOF
# '''

[[plugins]]
# インデントの可視化
repo = 'lukas-reineke/indent-blankline.nvim'
on_event = 'BufEnter'
hook_source = '''
lua << EOF
require("ibl").setup({scope = {show_exact_scope = true}})
EOF
'''

[[plugins]]
# テキストベースのスクロールバーを表示する
# スクロールバーと被って一番右端の文字が見えなくなるので注意.
repo = 'Xuyuanp/scrollbar.nvim'
on_event = ['BufEnter', 'BufNewFile']
hook_source = '''
augroup ScrollbarInit
  autocmd!
  autocmd WinScrolled,VimResized,QuitPre * silent! lua require('scrollbar').show()
  autocmd WinEnter,FocusGained           * silent! lua require('scrollbar').show()
  autocmd WinLeave,BufLeave,BufWinLeave,FocusLost            * silent! lua require('scrollbar').clear()
augroup end
'''


[[plugins]]
# 
repo = 'kyazdani42/nvim-web-devicons'

[[plugins]]
# 
repo = 'nvim-lualine/lualine.nvim'
depends = ['nvim-web-devicons']
on_event = 'BufRead'
hook_source = '''
lua << EOF
require('lualine').setup {
  options = {
    icons_enabled = true,
    theme = 'auto',
    component_separators = { left = '', right = ''},
    section_separators = { left = '', right = ''},
    disabled_filetypes = {},
    always_divide_middle = true,
  },
  sections = {
    lualine_a = {'mode'},
    lualine_b = {'branch', 'diagnostics'}, -- {'branch', 'diff', 'diagnostics'},
    lualine_c = {'filename'},
    lualine_x = {'encoding', 'fileformat', 'filetype'},
    lualine_y = {}, -- {'progress'},
    lualine_z = {}, -- {'location'}
  },
  inactive_sections = {
    lualine_a = {},
    lualine_b = {},
    lualine_c = {'filename'},
    lualine_x = {'location'},
    lualine_y = {},
    lualine_z = {}
  },
  tabline = {},
  extensions = {}
}
EOF
'''

[[plugins]]
# 
repo = 'akinsho/bufferline.nvim'
on_event = 'BufRead'
depends = ['nvim-web-devicons']
hook_source = '''
lua << EOF
vim.opt.termguicolors = true
require("bufferline").setup{}
EOF
'''


# ---------------------------------------------------------------------------------------------
# ファジーファインダー系
# ---------------------------------------------------------------------------------------------

[[plugins]]
# Reference: https://zenn.dev/vim_jp/articles/c0d75d1f3c7f33
# 使用の流れ.
# No  目的                            実際の操作
# 1   ddu.vimで一覧を表示する         :call ddu#start({オプション})
# 2   Input用のバッファを表示する     :call ddu#ui#do_action("openFilterWindow")
# 3   Itemを絞り込むワードを入力する  i キーワードを入力 <ESC>
# 4   一覧のバッファに移動する        :call ddu#ui#do_action("leaveFilterWindow")
# 5   Itemを選ぶ                      j や k で移動する
# 6   Kindのアクションを呼び出す      :call ddu#ui#do_action("itemAction", {"name": {アクション名}})
# 
repo = 'Shougo/ddu.vim'
on_event = 'BufEnter'
depends = ['denops.vim']
# hook_source = '''
# call ddu#custom#patch_global({
#     \     "ui": "ff",
#     \     "sourceOptions": {
#     \         "_": {
#     \             "matchers": ["matcher_substring"]
#     \         },
#     \     },
#     \ })
# 
# " DduNodeFilesで使用する設定を用意する
# call ddu#custom#patch_local("node-files", {
#     \     "sources": ["file_rec"],
#     \     "sourceParams": {
#     \         "file_rec": {
#     \             "ignoredDirectories": [".git", "node_modules"],
#     \         }
#     \     }
#     \ })
# 
# " DduWholeFilesで使用する設定を用意する
# call ddu#custom#patch_local("whole-files", {
#     \     "sources": ["file_rec"],
#     \     "sourceParams": {
#     \         "file_rec": {
#     \             "ignoredDirectories": [],
#     \         }
#     \     },
#     \     "sourceOptions": {
#     \         "file_rec": {
#     \             "maxItems": 50000
#     \         }
#     \     }
#     \ })
# 
# " ddu-ui-ff上でのみ有効なKeymap（`e`）を設定する
# autocmd FileType ddu-ff call s:ddu_ff_settings()
# function s:ddu_ff_settings() abort
#     nnoremap <buffer> e <Cmd>call ddu#ui#do_action('itemAction', {'name': 'open'})<CR>
# endfunction
# 
# " ddu#startを各オプションセット名で呼び出すコマンドを準備する
# command! DduNodeFiles call ddu#start({"name": "node-files", "sourceOptions": {"file_rec": {"path": getcwd()}}})
# command! DduWholeFiles call ddu#start({"name": "whole-files", "sourceOptions": {"file_rec": {"path": getcwd()}}})
# '''

# hook_source = '''
# lua << EOF
# --  config = function()
#     vim.fn["ddu#custom#patch_global"]({
#         ui = "ff",
#         uiParams = {
#           ff = {
#             filterFloatingPosition = "bottom",
#             filterSplitDirection = "floating",
#             floatingBorder = "rounded",
#             previewFloating = true,
#             previewFloatingBorder = "rounded",
#             previewFloatingTitle = "Preview",
#             previewSplit = "horizontal",
#             prompt = "> ",
#             split = "floating",
#             startFilter = true,
#           }
#         },
#         sourceOptions = {
#           _ = {
#             matchers = {
#               "matcher_substring",
#             },
#             ignoreCase = true,
#           },
#         },
#       })
#     vim.fn["ddu#custom#patch_local"]("file_recursive", {
#         sources = {
#           {
#             name = { "file_rec" },
#             options = {
#               converters = {
#                 "converter_devicon",
#               },
#             },
#             params = {
#               ignoredDirectories = { "node_modules", ".git", "dist", ".vscode" },
#             },
#           },
#         },
#         kindOptions = {
#           file = {
#             defaultAction = "open",
#           }
#         }
#       })
#     -- vim.fn["ddu#custom#patch_local"]("colorscheme", {
#     --     sources = {
#     --       {
#     --         name = { "colorscheme" },
#     --       },
#     --     },
#     --     kindOptions = {
#     --       colorscheme = {
#     --         defaultAction = "set",
#     --       }
#     --     }
#     --   })
# 
#     vim.api.nvim_create_autocmd("FileType",{
#         pattern = "ddu-ff",
#         callback = function()
#           local opts = { noremap = true, silent = true, buffer = true }
#           vim.keymap.set({ "n" }, "q", [[<Cmd>call ddu#ui#ff#do_action("quit")<CR>]], opts)
#           vim.keymap.set({ "n" }, "<Cr>", [[<Cmd>call ddu#ui#ff#do_action("itemAction")<CR>]], opts)
#           vim.keymap.set({ "n" }, "i", [[<Cmd>call ddu#ui#ff#do_action("openFilterWindow")<CR>]], opts)
#           vim.keymap.set({ "n" }, "P", [[<Cmd>call ddu#ui#ff#do_action("togglePreview")<CR>]], opts)
#         end,
#       }
#       )
# 
#     vim.api.nvim_create_autocmd("FileType",{
#         pattern = "ddu-ff-filter",
#         callback = function()
#           local opts = { noremap = true, silent = true, buffer = true }
#           vim.keymap.set({ "n", "i" }, "<CR>", [[<Esc><Cmd>close<CR>]], opts)
#         end,
#       }
#       )
# --  end,
# EOF
# '''

hook_source = '''
call ddu#custom#patch_global({
    \ "kindOptions": {
    \   "lsp": {
    \     "defaultAction": 'open',
    \   },
    \   "lsp_codeAction": {
    \     "defaultAction": 'apply',
    \   },
    \ },
    \})

" command! DduLspDefinition call ddu#start({
"     \ "sync": v:true,
"     \ "sources": [{
"     \   "name": 'lsp_definition',
"     \ }],
"     \ "uiParams": {
"     \   "ff": {
"     \     "immediateAction": 'open',
"     \   },
"     \ }
"     \})
" 
" " # TODO: 
" command! DduLspReferences call ddu#start({
"     \ "sync": v:true,
"     \ "sources": [{
"     \   "name": 'lsp_references',
"     \ }],
"     \ "uiParams": {
"     \   "ff": {
"     \     "immediateAction": 'open',
"     \     "startFilter": v:false,
"     \   },
"     \ }
"     \})

" command! DduLspDiagnostic call ddu#start({
"     \ "ui": "ff",
"     \ "sync": v:true,
"     \ "sourceOptions": {
"     \   "_": {
"     \     "converters": [
"     \        {
"     \          "name": "converter_lsp_diagnostic",
"     \          "params": {
"     \            "iconMap": {
"     \              "Error": "E",
"     \              "Warning": "W",
"     \              "Info": "I",
"     \              "Hint": "H",
"     \            },
"     \            "columnLength": 100,
"     \          },
"     \        },
"     \      ],
"     \   },
"     \ },
"     \ "sources": [{
"     \   "name": 'lsp_diagnostic',
"     \   "params": { "buffer": v:null, },
"     \ }],
"     \ "uiParams": {
"     \   "ff": {
"     \     "immediateAction": 'open',
"     \     "startFilter": v:false,
"     \   },
"     \  },
"     \})
" "     \ "sourceOptions": {
" "     \   "_": {
" "     \     "converters": ["converter_lsp_diagnostic"],
" "     \   },
" "     \ },
" "     \ "FilterParams": {
" "     \   "converter_lsp_diagnostic": {
" "     \     "IconMap": {
" "     \       "Warning": "b",
" "     \     },
" "     \   },
" "     \ },

command! DduLspDucmentSymbol call ddu#start({
    \ "ui": "ff",
    \ "sources": [{
    \   "name": 'lsp_documentSymbol',
    \   "options": {
    \     "converters": [
    \       {
    \         "name": "converter_lsp_symbol",
    \         "params": {
    \           "iconMap": {
    \             "File": "-",
    \             "Module": "-",
    \             "Namespace": "-",
    \             "Package": "-",
    \             "Class": "-",
    \             "Method": "-",
    \             "Property": "-",
    \             "Field": "-",
    \             "Constructor": "-",
    \             "Enum": "-",
    \             "Interface": "-",
    \             "Function": "-",
    \             "Variable": "-",
    \             "Constant": "-",
    \             "String": "-",
    \             "Number": "-",
    \             "Boolean": "-",
    \             "Array": "-",
    \             "Object": "-",
    \             "Key": "-",
    \             "Null": "-",
    \             "EnumMember": "-",
    \             "Struct": "-",
    \             "Event": "-",
    \             "Operator": "-",
    \             "TypeParameter": "-",
    \           },
    \         },
    \       },
    \     ],
    \   },
    \ }],
    \ "uiParams": {
    \   "ff": {
    \     "startFilter": v:false,
    \     "displayTree": v:true,
    \   },
    \ }
    \})

" " Not work on pylsp.
" command! DduLspWorkspaceSymbol call ddu#start({
"     \ "ui": "ff",
"     \ "sources": [{
"     \   "name": 'lsp_workspaceSymbol',
"     \ }],
"     \ "sourceOptions": {
"     \   "lsp": {
"     \     "volatile": v:true,
"     \   },
"     \ },
"     \ "uiParams": {
"     \   "ff": {
"     \     "ignoreEmpty": v:false,
"     \     "displayTree": v:true,
"     \   },
"     \ }
"     \})

" " Not work on pylsp.
" command! DduLspCallHierarchy call ddu#start({
"     \ "sources": [{
"     \   "name": 'lsp_callHierarchy',
"     \   "params": {
"     \     "method": 'callHierarchy/outgoingCalls',
"     \   }
"     \ }],
"     \ "uiParams": {
"     \   "ff": {
"     \     "displayTree": v:true,
"     \     "startFilter": v:false,
"     \   },
"     \ }
"     \})

'''


[[plugins]]
# ファジーファインダー風のUI
repo = 'Shougo/ddu-ui-ff'
on_source = 'ddu.vim'

[[plugins]]
# ファイル一覧を取得するsource
repo = 'Shougo/ddu-source-file_rec'
on_source = 'ddu.vim'

[[plugins]]
# Openなどファイル関連の処理が定義されているkind
repo = 'Shougo/ddu-kind-file'
on_source = 'ddu.vim'

[[plugins]]
# Openなどファイル関連の処理が定義されているkind
repo = 'Shougo/ddu-source-dummy'
on_source = 'ddu.vim'

[[plugins]]
# 部分文字列への完全一致によってsourceを絞り込むfilter(matcher)
repo = 'Shougo/ddu-filter-matcher_substring'
on_source = 'ddu.vim'

[[plugins]]
# sourceのファイル名にnordfontのアイコンを付けるfilter(converter)
repo = 'uga-rosa/ddu-filter-converter_devicon'
on_source = 'ddu.vim'

[[plugins]]
# LSPの情報を取得するsource
repo = 'uga-rosa/ddu-source-lsp'
on_source = 'ddu.vim'
# hook_source = '''
# lua << EOF
# -- Reference: 
# 
# 
# local helper = {}
# ---@param name? string If nil, map is set globally
# ---@param callback fun(map: fun(lhs: string, rhs: string|function, opts?: table))
# function helper.ff_map(name, callback)
#   name = name or "default"
#   vim.api.nvim_create_autocmd("FileType", {
#     pattern = "ddu-ff",
#     group = vim.api.nvim_create_augroup("ddu-ui-ff-map-" .. name, { clear = false }),
#     callback = function()
#       -- Enable `file` map also for `file:foo`
#       if name == "default" or string.find(vim.b.ddu_ui_name, name) then
#         callback(function(lhs, rhs, opts)
#           opts = vim.tbl_extend("keep", opts or {}, { nowait = true, buffer = true, silent = true })
#           vim.keymap.set("n", lhs, rhs, opts)
#         end)
#       end
#     end,
#   })
# end
# 
# ---@param name? string If nil, map is set globally
# ---@param callback fun(map: fun(mode: string|string[], lhs: string, rhs: string|function, opts?: table))
# function helper.ff_filter_map(name, callback)
#   name = name or "default"
#   vim.api.nvim_create_autocmd("FileType", {
#     pattern = "ddu-ff-filter",
#     group = vim.api.nvim_create_augroup("ddu-ui-ff-filter-map-" .. name, { clear = false }),
#     callback = function()
#       -- Enable `file` map also for `file:foo`
#       if name == "default" or string.find(vim.b.ddu_ui_name, name) then
#         callback(function(mode, lhs, rhs, opts)
#           opts = vim.tbl_extend("keep", opts or {}, { nowait = true, buffer = true, silent = true })
#           vim.keymap.set(mode, lhs, rhs, opts)
#         end)
#       end
#     end,
#   })
# end
# 
# ---@param dict table
# function helper.patch_global(dict)
#   vim.fn["ddu#custom#patch_global"](dict)
# end
# 
# ---@param name string
# ---@param dict table
# function helper.patch_local(name, dict)
#   vim.fn["ddu#custom#patch_local"](name, dict)
# end
# 
# -- # ---------------------------------------------------------------------------------------
# -- # ui-ff.lua
# -- # ---------------------------------------------------------------------------------------
# helper.ff_map(nil, function(map)
#   -- Enter filter
#   map("i", helper.action("openFilterWindow"))
#   -- Close UI
#   map("<Esc>", helper.action("quit"))
#   -- Toggle selected state for all items
#   map("a", helper.action("toggleAllItems"))
#   -- Toggle selected state for cursor item
#   map(" ", helper.action("toggleSelectItem"))
#   -- Expand item tree
#   map("e", helper.action("expandItem", { mode = "toggle" }))
#   -- Show available actions
#   map("+", helper.action("chooseAction"))
#   -- Toggle preview
#   map("p", helper.action("toggleAutoAction"))
# end)
# 
# helper.ff_filter_map(nil, function(map)
#   -- Close UI
#   map("i", "<C-c>", helper.action("quit", nil, true))
#   -- Close filter window
#   map("n", "<Esc>", helper.action("closeFilterWindow", nil, true))
#   -- Move cursor
#   map("i", "<C-n>", helper.execute("normal j"))
#   map("i", "<C-p>", helper.execute("normal k"))
# end)
# 
# 
# helper.patch_global({
#   ui = "ff",
#   uiParams = {
#     ff = {
#       startFilter = true,
#       prompt = "> ",
#       cursorPos = 0,
#       split = "floating",
#       floatingBorder = "single",
#       filterFloatingPosition = "top",
#       autoAction = {
#         name = "preview",
#       },
#       startAutoAction = true,
#       previewFloating = true,
#       previewFloatingBorder = "single",
#       previewSplit = "vertical",
#       previewFloatingTitle = "Preview",
#       previewWindowOptions = {
#         { "&signcolumn", "no" },
#         { "&foldcolumn", 0 },
#         { "&foldenable", 0 },
#         { "&number", 0 },
#         { "&wrap", 0 },
#         { "&scrolloff", 0 },
#       },
#       highlights = {
#         floating = "Normal",
#         floatingBorder = "Normal",
#       },
#       ignoreEmpty = true,
#     },
#   },
# })
# 
# local function resize()
#   local lines = vim.opt.lines:get()
#   local height, row = math.floor(lines * 0.8), math.floor(lines * 0.1)
#   local columns = vim.opt.columns:get()
#   local width, col = math.floor(columns * 0.8), math.floor(columns * 0.1)
#   local previewWidth = math.floor(width / 2)
# 
#   helper.patch_global({
#     uiParams = {
#       ff = {
#         winHeight = height,
#         winRow = row,
#         winWidth = width,
#         winCol = col,
#         previewHeight = height,
#         previewRow = row,
#         previewWidth = previewWidth,
#         previewCol = col + (width - previewWidth),
#       },
#     },
#   })
# end
# resize()
# 
# vim.api.nvim_create_autocmd("VimResized", {
#   callback = resize,
# })
# 
# 
# -- # ---------------------------------------------------------------------------------------
# -- # source-lsp.lua
# -- # ---------------------------------------------------------------------------------------
# 
# helper.ff_map("lsp", function(map)
#   map("<C-x>", helper.item_action("open", { command = "split" }))
#   map("<C-v>", helper.item_action("open", { command = "vsplit" }))
#   map("q", helper.item_action("quickfix"))
# end)
# 
# helper.ff_filter_map("lsp", function(map)
#   map("i", "<C-x>", helper.item_action("open", { command = "split" }, true))
#   map("i", "<C-v>", helper.item_action("open", { command = "vsplit" }, true))
# end)
# 
# init = function()
#   vim.keymap.set("n", "gd", "<Cmd>Ddu lsp:definition<CR>")
#   vim.keymap.set("n", "gt", "<Cmd>Ddu lsp:type_definition<CR>")
#   vim.keymap.set("n", "gr", "<Cmd>Ddu lsp:references<CR>")
#   vim.keymap.set({ "n", "x" }, "<Space>a", "<Cmd>Ddu lsp:code_action<CR>")
# end,
# config = function()
#   helper.patch_global({
#     kindOptions = {
#       lsp = {
#         defaultAction = "open",
#       },
#       lsp_codeAction = {
#         defaultAction = "apply",
#       },
#     },
#   })
# 
#   for name, method in pairs({
#     ["lsp:declaration"] = "textDocument/declaration",
#     ["lsp:definition"] = "textDocument/definition",
#     ["lsp:type_definition"] = "textDocument/typeDefinition",
#     ["lsp:implementation"] = "textDocument/implementation",
#   }) do
#     helper.patch_local(name, {
#       sources = {
#         {
#           name = "lsp_definition",
#           params = {
#             method = method,
#           },
#         },
#       },
#       sync = true,
#       uiParams = {
#         ff = {
#           immediateAction = "open",
#         },
#       },
#     })
#   end
# 
#   helper.patch_local("lsp:references", {
#     sources = { "lsp_references" },
#   })
# 
#   ---@param word string
#   ---@param color string
#   ---@return { name: string, params: table }
#   local function separator(word, color)
#     local hlGroup = "DduDummy" .. color:gsub("[^a-zA-Z0-9]", "")
#     vim.api.nvim_set_hl(0, hlGroup, { fg = color })
#     return {
#       name = "dummy",
#       params = { word = word, hlGroup = hlGroup },
#     }
#   end
# 
#   helper.patch_local("lsp:definition_all", {
#     sources = {
#       separator(">>Definition<<", "#fc514e"),
#       { name = "lsp_definition", params = { method = "textDocument/definition" } },
#       separator(">>Type definition<<", "#ffcb8b"),
#       { name = "lsp_definition", params = { method = "textDocument/typeDefinition" } },
#       separator(">>Declaration<<", "#21c7a8"),
#       { name = "lsp_definition", params = { method = "textDocument/declaration" } },
#       separator(">>Implementation<<", "#5e97ec"),
#       { name = "lsp_definition", params = { method = "textDocument/implementation" } },
#     },
#   })
# 
#   helper.patch_local("lsp:finder", {
#     sources = {
#       separator(">>Definition<<", "#fc514e"),
#       { name = "lsp_definition" },
#       separator(">>References<<", "#5e97ec"),
#       { name = "lsp_references", params = { includeDeclaration = false } },
#     },
#   })
# 
#   helper.patch_local("lsp:document_symbol", {
#     sources = {
#       {
#         name = "lsp_documentSymbol",
#         options = {
#           converters = { "converter_lsp_symbol" },
#         },
#       },
#     },
#   })
# 
#   helper.patch_local("lsp:dynamic_workspaceSymbol", {
#     sources = {
#       {
#         name = "lsp_workspaceSymbol",
#         options = { volatile = true },
#       },
#     },
#     uiParams = {
#       ff = {
#         ignoreEmpty = false,
#       },
#     },
#   })
# 
#   helper.patch_local("lsp:hierarchy", {
#     uiParams = {
#       ff = {
#         displayTree = true,
#         startFilter = false,
#       },
#     },
#   })
# 
#   for name, method in pairs({
#     ["lsp:incoming_call"] = "callHierarchy/incomingCalls",
#     ["lsp:outgoing_call"] = "callHierarchy/outgoingCalls",
#     ["lsp:super_type"] = "typeHierarchy/supertypes",
#     ["lsp:sub_type"] = "typeHierarchy/subtypes",
#   }) do
#     helper.patch_local(name, {
#       sources = {
#         {
#           name = "lsp_callHierarchy",
#           params = { method = method },
#         },
#       },
#       uiParams = {
#         ff = {
#           displayTree = true,
#           startFilter = false,
#         },
#       },
#     })
#   end
# 
#   helper.patch_local("lsp:diagnostic", {
#     sourceOptions = {
#       _ = {
#         converters = { "converter_lsp_diagnostic" },
#       },
#     },
#   })
# 
#   for subcommand, buffer in pairs({
#     lsp_diagnostic = 0,
#     lsp_diagnostic_all = vim.NIL,
#   }) do
#     helper.patch_local(subcommand, {
#       sources = {
#         {
#           name = "lsp_diagnostic",
#           params = { buffer = buffer },
#         },
#       },
#     })
#   end
# 
#   helper.patch_local("lsp:code_action", {
#     sources = { "lsp_codeAction" },
#   })
# end,
# 
# 
# -- # ---------------------------------------------------------------------------------------
# -- # source-dummy.lua
# -- # ---------------------------------------------------------------------------------------
# 
# ---@param items table[] DduItem[]
# ---@param index number
# ---@return boolean
# local function is_dummy(items, index)
#   return items[index] and items[index].__sourceName == "dummy"
# end
# 
# ---@param dir number
# ---@return function
# local function move_ignore_dummy(dir)
#   return function()
#     local items = vim.fn["ddu#ui#get_items"]()
#     local index = vim.fn.line(".") + dir
# 
#     while is_dummy(items, index) do
#       index = index + dir
#     end
#     if 1 <= index and index <= #items then
#       vim.cmd("normal! " .. index .. "gg")
#     end
#   end
# end
# 
# helper.ff_map("dummy", function(map)
#   -- Move cursor ignoring dummy items
#   map("j", move_ignore_dummy(1))
#   map("k", move_ignore_dummy(-1))
# end)
# 
# ---@type LazySpec
# local spec = {
#   "Shougo/ddu-source-dummy",
#   dependencies = "ddu.vim",
#   config = function()
#     helper.patch_global({
#       sourceOptions = {
#         dummy = {
#           matchers = {},
#           sorters = {},
#           converters = {},
#         },
#       },
#     })
#   end,
# }
# 
# EOF
# '''

# "4513ECHO/ddu-source-colorscheme",


# ---------------------------------------------------------------------------------------------
# Git
# ---------------------------------------------------------------------------------------------

[[plugins]]
# 行の横に差分情報表示.
repo = 'lewis6991/gitsigns.nvim'
on_event = "BufEnter"
hook_source = '''
lua << EOF
-- provided default setting
require('gitsigns').setup {
  signs = {
    add          = { text = '│' },
    change       = { text = '│' },
    delete       = { text = '_' },
    topdelete    = { text = '‾' },
    changedelete = { text = '~' },
    untracked    = { text = '┆' },
  },
  signcolumn = true,  -- Toggle with `:Gitsigns toggle_signs`
  numhl      = false, -- Toggle with `:Gitsigns toggle_numhl`
  linehl     = false, -- Toggle with `:Gitsigns toggle_linehl`
  word_diff  = false, -- Toggle with `:Gitsigns toggle_word_diff`
  watch_gitdir = {
    follow_files = true
  },
  attach_to_untracked = true,
  current_line_blame = false, -- Toggle with `:Gitsigns toggle_current_line_blame`
  current_line_blame_opts = {
    virt_text = true,
    virt_text_pos = 'eol', -- 'eol' | 'overlay' | 'right_align'
    delay = 1000,
    ignore_whitespace = false,
    virt_text_priority = 100,
  },
  current_line_blame_formatter = '<author>, <author_time:%Y-%m-%d> - <summary>',
  sign_priority = 6,
  update_debounce = 100,
  status_formatter = nil, -- Use default
  max_file_length = 40000, -- Disable if file is longer than this (in lines)
  preview_config = {
    -- Options passed to nvim_open_win
    border = 'single',
    style = 'minimal',
    relative = 'cursor',
    row = 0,
    col = 1
  },
  yadm = {
    enable = false
  },
}
EOF
'''

