# ---------------------------------------------------------------------------------------------
# プラットフォーム系ツール.
# 他ツールが動作する為の依存関係.
# ---------------------------------------------------------------------------------------------

# Deno依存のプラグインを動作させる
[[plugins]]
repo = 'vim-denops/denops.vim'


# ---------------------------------------------------------------------------------------------
# カスタマイズ設定の索引ツール.
# ---------------------------------------------------------------------------------------------

[[plugins]]
# キーバインドを通知
repo = 'liuchengxu/vim-which-key'
hook_add = '''
nnoremap <silent> <leader> :WhichKey '<Space>'<CR>
'''


# # ---------------------------------------------------------------------------------------------
# # 画面描画ツール(色, アイコン,ステータスラインなど)
# # ---------------------------------------------------------------------------------------------

[[plugins]]
repo = 'nvim-treesitter/nvim-treesitter'
if = 'has("nvim")'
on_event = 'BufRead'
hook_post_update = 'TSUpdate'
hook_source = '''
lua <<EOF
require'nvim-treesitter.configs'.setup {
    -- ensure_installed = 'all',
    highlight = {
        enable = true,
        disable = {},
    },
}
EOF
'''

[[plugins]]
# インデントの可視化
repo = 'lukas-reineke/indent-blankline.nvim'
on_event = 'BufEnter'
hook_source = '''
lua << EOF
require("ibl").setup({scope = {show_exact_scope = false}})
EOF
'''

[[plugins]]
# テキストベースのスクロールバーを表示する
# スクロールバーと被って一番右端の文字が見えなくなるので注意.
repo = 'Xuyuanp/scrollbar.nvim'
on_event = ['BufEnter', 'BufNewFile']
hook_source = '''
augroup ScrollbarInit
  autocmd!
  autocmd WinScrolled,VimResized,QuitPre * silent! lua require('scrollbar').show()
  autocmd WinEnter,FocusGained           * silent! lua require('scrollbar').show()
  autocmd WinLeave,BufLeave,BufWinLeave,FocusLost            * silent! lua require('scrollbar').clear()
augroup end
'''


[[plugins]]
repo = 'kyazdani42/nvim-web-devicons'

[[plugins]]
repo = 'nvim-lualine/lualine.nvim'
on_event = 'BufRead'
hook_source = '''
lua << EOF
vim.opt.laststatus = 3 -- splitしてもステータスラインは分割されない.


local function diff_source()
  local gitsigns = vim.b.gitsigns_status_dict
  if gitsigns then
    return {
      added = gitsigns.added,
      modified = gitsigns.changed,
      removed = gitsigns.removed
    }
  end
end

-- stylua: ignore
local colors = {
  blue   = '#80a0ff',
  cyan   = '#79dac8',
  black  = '#080808',
  white  = '#c6c6c6',
  red    = '#ff5189',
  violet = '#d183e8',
  grey   = '#303030',
}

local bubbles_theme = {
  normal = {
    a = { fg = colors.black, bg = colors.violet },
    b = { fg = colors.white, bg = colors.grey },
    c = { fg = colors.black, bg = colors.black },
  },

  insert = { a = { fg = colors.black, bg = colors.blue } },
  visual = { a = { fg = colors.black, bg = colors.cyan } },
  replace = { a = { fg = colors.black, bg = colors.red } },

  inactive = {
    a = { fg = colors.white, bg = colors.black },
    b = { fg = colors.white, bg = colors.black },
    c = { fg = colors.black, bg = colors.black },
  },
}

-- local function get_color_by_branchname(branch_name)
--   print(branch_name)
--   -- if (string.len(branch_name) >= 7) and (string.sub(branch_name, 1, 7) == "feature") then
--   --   return {fg = colors.cyan}
--   -- else
--   --   return {fg = colors.violet}
--   -- end
-- 
--   -- if branch_name and (string.find(branch_name, "feature")) then
--   if branch_name then
--     if (string.find(branch_name, "feature")) then
--       return {fg = colors.cyan}
--     else
--       return {fg = colors.gray}
--     end
--   else
--     return {fg = colors.red}
--   end
--   -- if (string.len(branch_name) >= 15) then
--   --   if (string.sub(branch_name, 1, 7) == "feature") then
--   --     return {fg = colors.red}
--   --   else
--   --     return {fg = colors.gray}
--   --   end
--   -- else
--   --   return {fg = colors.violet}
--   -- end
-- end



require('lualine').setup {
  options = {
    theme = bubbles_theme,
    component_separators = '|',
    section_separators = { left = '', right = '' },
    globalstatus = true, -- laststatus=3(ステータスラインの分割防止)に対応.
  },
  sections = {
    lualine_a = {
      { 'mode', separator = { left = '' }, right_padding = 2 },
    },
    -- lualine_b = {'branch', { 'diff', symbols = { added = ' ', modified = ' ', removed = ' ' }, source = diff_source }, 'diagnostics', 'filename', 'filetype'},
    lualine_b = {
      -- 'branch',
      {'b:gitsigns_head', color={fg=colors.red}},
      -- {'b:gitsigns_head', color=get_color_by_branchname(vim.b.gitsigns_head)},
      {'diff', symbols = { added='A:', modified='M:', removed='D:' }, source=diff_source, },
      {'filetype', icon_only=true, icon={align="left"}},
      'filename',
      'diagnostics',
    },
    -- lualine_b = {
    --   {
    --     "aerial",
    --     -- The separator to be used to separate symbols in status line.
    --     sep = " ) ",

    --     -- The number of symbols to render top-down. In order to render only 'N' last
    --     -- symbols, negative numbers may be supplied. For instance, 'depth = -1' can
    --     -- be used in order to render only current symbol.
    --     depth = nil,

    --     -- When 'dense' mode is on, icons are not rendered near their symbols. Only
    --     -- a single icon that represents the kind of current symbol is rendered at
    --     -- the beginning of status line.
    --     dense = false,

    --     -- The separator to be used to separate symbols in dense mode.
    --     dense_sep = ".",

    --     -- Color the symbol icons.
    --     colored = true,
    --   },
    -- },
    lualine_c = {'not visible area'},
    lualine_x = {},
    lualine_y = {'encoding', 'fileformat'},
    lualine_z = {
      { 'location', separator = { right = '' }, left_padding = 2 },
    },
  },
  inactive_sections = {
    lualine_a = { 'filename' },
    lualine_b = {},
    lualine_c = {},
    lualine_x = {},
    lualine_y = {},
    lualine_z = { 'location' },
  },
  tabline = {},
  extensions = {'aerial'},
  
}
EOF
'''

[[plugins]]
# 
repo = 'akinsho/bufferline.nvim'
on_event = 'BufRead'
depends = ['nvim-web-devicons']
hook_source = '''
lua << EOF
vim.opt.termguicolors = true
require("bufferline").setup{}
EOF
'''

# ---------------------------------------------------------------------------------------------
# ファイル/テキスト編集補助ツール.
# ---------------------------------------------------------------------------------------------

[[plugins]]
# treesitterを利用した自動インデントプラグイン.
# treesitterや別プラグインだとバグや誤動作がちょくちょくある.
repo = 'yioneko/nvim-yati'
on_source = 'nvim-treesitter'
hook_source = '''
lua <<EOF
require("nvim-treesitter.configs").setup {
  yati = { enable = true },
}
EOF
'''

# [[plugins]] # TODO: 全然使ってないので一時的に削除. 使うのか再考する.
# # プロジェクト内のファイルの一斉置換
# repo ='nvim-pack/nvim-spectre'
# depends = ['plenary.nvim']
# # on_source = 'nvim-lspconfig'
# on_event = 'BufRead'
# hook_source = '''
# lua << EOF
# require('spectre').setup()
# EOF
# '''
# hook_add = '''
# nnoremap <leader>R :lua require('spectre').open()<CR>
# "search current word
# nnoremap <leader>rw :lua require('spectre').open_visual({select_word=true})<CR>
# vnoremap <leader>r :lua require('spectre').open_visual()<CR>
# "  search in current file
# nnoremap <leader>rp viw:lua require('spectre').open_file_search()<cr>
# '''


# ---------------------------------------------------------------------------------------------
# カーソル移動補助ツール.
# ---------------------------------------------------------------------------------------------

[[plugins]]
# Migemo互換の機能によるローマ字入力でも日本語検索ができる.
# Typescriptで実装されており,Migemoのインストールはいらない.
# このプラグイン単体だとコマンドの提供やkensaku.vimへのキーマッピングは行われず,
# 呼び出す為にはkensaku-search.vimやkensaku-comanndo.vimもセットで必要.
repo = 'lambdalisue/kensaku.vim'
on_source = ["denops.vim"]

[[plugins]]
# / での検索時にkensaku.vimを有効化.
# Enterを押した時に日本語用の検索文字列が展開される為,
# 検索文字列入力中はマッチする文字にハイライトがでないことに注意.
repo = 'lambdalisue/kensaku-search.vim'
on_source = ["kensaku.vim"]
hook_source = '''
cnoremap <CR> <Plug>(kensaku-search-replace)<CR>
'''

[[plugins]]
# EasyMotion系ツール.
# 大文字はヒット文字に飛ぶために使われる為、検索時の入力はIgunoreCaseとなる.
# kensaku.vimとの連携によってローマ字入力で日本語がヒットする.
repo = 'yuki-yano/fuzzy-motion.vim'
on_source = ["kensaku.vim"]
hook_source = '''
let g:fuzzy_motion_disable_match_highlight=v:true
let g:fuzzy_motion_matchers=["fzf", "kensaku"]
nnoremap <buffer><silent>ss :FuzzyMotion<CR>
'''


[[plugins]]
# スムーズスクロール
repo = 'karb94/neoscroll.nvim'
on_event = 'BufEnter'
hook_source = '''
lua <<EOF
require('neoscroll').setup({
    mappings = {'<C-u>', '<C-d>', '<C-y>', '<C-e>'},
})
-- require('neoscroll').setup()
EOF
'''

# [[plugins]] # エラーが出て何個目かの情報が表示されない. # TODO: 調査.
# # 検索にヒットしたものが何個中何個目かをvertualtextで表示する
# repo = 'kevinhwang91/nvim-hlslens'
# on_event = 'BufEnter'
# hook_add = '''
# noremap <silent> n <Cmd>execute('normal! ' . v:count1 . 'n')<CR>
#             \<Cmd>lua require('hlslens').start()<CR>
# noremap <silent> N <Cmd>execute('normal! ' . v:count1 . 'N')<CR>
#             \<Cmd>lua require('hlslens').start()<CR>
# '''
# # hook_source = '''
# # lua << EOF
# # require('hlslens').setup()
# # 
# # local kopts = {noremap = true, silent = true}
# # 
# # vim.api.nvim_set_keymap('n', 'n',
# #     [[<Cmd>execute('normal! ' . v:count1 . 'n')<CR><Cmd>lua require('hlslens').start()<CR>]],
# #         kopts)
# # vim.api.nvim_set_keymap('n', 'N',
# #     [[<Cmd>execute('normal! ' . v:count1 . 'N')<CR><Cmd>lua require('hlslens').start()<CR>]],
# #         kopts)
# # vim.api.nvim_set_keymap('n', '*', [[*<Cmd>lua require('hlslens').start()<CR>]], kopts)
# # vim.api.nvim_set_keymap('n', '#', [[#<Cmd>lua require('hlslens').start()<CR>]], kopts)
# # vim.api.nvim_set_keymap('n', 'g*', [[g*<Cmd>lua require('hlslens').start()<CR>]], kopts)
# # vim.api.nvim_set_keymap('n', 'g#', [[g#<Cmd>lua require('hlslens').start()<CR>]], kopts)
# # EOF
# # '''

[[plugins]] # nvim-hlslensを一旦消したのでこっちも合わせて消しておく # TODO: 戻す.
# 検索時に勝手にカーソルが移動するのを防ぐ.
# 選択範囲の文字列でアスタリスク検索する機能ももつ.
# キーマップにvim-asteriskとnvim-hlslensの機能両方を結びつける為に、nvim-hlslensをdependsにしている.
repo = 'haya14busa/vim-asterisk'
# depends = ['nvim-hlslens']
# # on_source = 'nvim-hlslens'
# hook_add = '''
# map * <Plug>(asterisk-z*)<Cmd>lua require('hlslens').start()<CR>
# map # <Plug>(asterisk-z#)<Cmd>lua require('hlslens').start()<CR>
# map g* <Plug>(asterisk-gz*)<Cmd>lua require('hlslens').start()<CR>
# map g# <Plug>(asterisk-gz#)<Cmd>lua require('hlslens').start()<CR>
# let g:asterisk#keeppos = 1
# # '''
on_event = 'BufEnter'
hook_add = '''
map * <Plug>(asterisk-z*)
map # <Plug>(asterisk-z#)
map g* <Plug>(asterisk-gz*)
map g# <Plug>(asterisk-gz#)
let g:asterisk#keeppos = 1
'''

# ---------------------------------------------------------------------------------------------
# プログラミング補助.
# LSPセットアップ.
# ---------------------------------------------------------------------------------------------

[[plugins]]
repo = 'neovim/nvim-lspconfig'
# on_event = 'BufEnter'
# depends = ["ddc-nvim-lsp-setup"]
on_source = ["ddc-nvim-lsp-setup"]
hook_source = '''
lua << EOF

-- -- これつけるとyamllsが動かない.
-- -- nvim-lsp.yamlls.setup {
-- --   settings = {
-- --     yaml = {
-- --       schemas = require('schemastore').yaml.schemas {
-- --        select = {
-- --          'docker-compose.yml',
-- --        },
-- --      },
-- --     },
-- --   },
-- -- }
-- 
-- require'lspconfig'.yamlls.setup{
--    cmd = {"~/.local/share/nvim/lsp_servers/yaml/node_modules/.bin/yaml-language-server", "--stdio"},
--    -- on_attach = require'lsp'.common_on_attach,
--    settings = {
--        yaml = {
--            format = {
--                    enable = true,
--            },
--            hover = true,
--            completion = true,
-- 
--            customTags = {
--                "!fn",
--                "!And",
--                "!If",
--                "!Not",
--                "!Equals",
--                "!Or",
--                "!FindInMap sequence",
--                "!Base64",
--                "!Cidr",
--                "!Ref",
--                "!Ref Scalar",
--                "!Sub",
--                "!GetAtt",
--                "!GetAZs",
--                "!ImportValue",
--                "!Select",
--                "!Split",
--                "!Join sequence"
--            },
--        },
--    },
--  }

EOF
'''

[[plugins]]
# mason.nvimでインストールしたプラグインをnvim-lspconfigの設定に流す橋渡し役.
# mason.nvimで認識されるプラグイン名とnvim-lspconfigで認識されるLaunguage Server名が異なっていることがあったり、そういう設定の面倒事を吸収している.
# nvim-lspconfigにかける設定項目もこちらに書く方が無難か.
repo ='williamboman/mason-lspconfig.nvim'
on_source = ['nvim-lspconfig', "masson.nvim"]
hook_source = '''
lua << EOF
require("mason-lspconfig").setup()
require("mason-lspconfig").setup_handlers {
  function(server_name) -- default handler (optional)
    require("lspconfig")[server_name].setup {
      -- on_attach = on_attach,
      on_attach = function (client, bufnr)
        local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end
        local function buf_set_option(...) vim.api.nvim_buf_set_option(bufnr, ...) end

        local opts = { noremap=true, silent=true }
        buf_set_keymap('n', 'gd', '<Cmd>lua vim.lsp.buf.definition()<CR>', opts)
        buf_set_keymap('n', 'gK', '<Cmd>lua vim.lsp.buf.hover()<CR>', opts)
        buf_set_keymap('n', 'gi', '<cmd>lua vim.lsp.buf.implementation()<CR>', opts)
        buf_set_keymap('n', 'gs', '<cmd>lua vim.lsp.buf.signature_help()<CR>', opts)
        -- dduで実行.
        -- buf_set_keymap('n', 'gr', '<cmd>lua vim.lsp.buf.references()<CR>', opts)
        buf_set_keymap('n', 'gx', '<cmd>lua vim.diagnostic.open_float(0, {scope="line"})<CR>', opts)
        buf_set_keymap('n', 'g[', '<cmd>lua vim.diagnostic.goto_prev({float={...}})<CR>', opts)
        buf_set_keymap('n', 'g]', '<cmd>lua vim.diagnostic.goto_next({float={...}})<CR>', opts)
      end
    }
  end
}

-- # ---------------------------------------------------------------------------------------------
-- # ruffと重複しているpylspのリントを消す.
-- # ---------------------------------------------------------------------------------------------
require("lspconfig").pylsp.setup {
-- local servers = {
--   pylsp = {
--     cmd = {"pylsp"},
--     root_dir = function(fname)
--       local root_files = {
--         'pyproject.toml',
--         'setup.py',
--         'setup.cfg',
--         'requirements.txt',
--         'Pipfile',
--       }
--       return util.root_pattern(unpack(root_files))(fname) or util.find_git_ancestor(fname)
--     end,
  settings = {
    pylsp = {
      -- configurationSources = {"pylint"},
      plugins = {
        pylint = { enabled = true },
        autpep8 = { enabled = false },
        flake8 = { enabled = false },
        pycodestyle = { enabled = false },
        pyflakes = { enabled = false },
      }
    }
  }
--  }
-- }
}

-- # ---------------------------------------------------------------------------------------------
-- # diagnosticのエディタ画面への描画設定.
-- # ---------------------------------------------------------------------------------------------
vim.lsp.handlers["textDocument/publishDiagnostics"] = vim.lsp.with(
  vim.lsp.diagnostic.on_publish_diagnostics, {
    -- -- Enable underline, use default values
    -- underline = true,
    underline = false,
    -- -- Enable virtual text, override spacing to 4
    -- virtual_text = {
    --   spacing = 4,
    -- },
    virtual_text = true,
    -- Use a function to dynamically turn signs off
    -- and on, using buffer local variables
    -- signs = function(bufnr, client_id)
    --   return vim.bo[bufnr].show_signs == false
    -- end,
    signs = true,
    -- -- Disable a feature
    update_in_insert = false,
  }
)


EOF
'''


# ---------------------------------------------------------------------------------------------
# プログラミング補助.
# 自動補完などの入力補助系.
# ---------------------------------------------------------------------------------------------

# 入力に対応して様々な補完候補を集約してポップアップする.
# 補完候補を生成するのはsource用プラグインの役割.
[[plugins]]
repo = 'Shougo/ddc.vim'
# on_event = 'InsertEnter'
on_event = 'BufEnter'
depends = ['denops.vim']
hook_source = '''
call ddc#custom#patch_global('sources', ['nvim-lsp', 'around', 'file'])
call ddc#custom#patch_global('ui', 'pum')
call ddc#custom#patch_global('sourceOptions', {
     \ '_': {
     \   'matchers': ['matcher_fuzzy'],
     \   'sorters': ['sorter_fuzzy'],
     \   'converters': ['converter_fuzzy'],
     \ },
     \ 'around': {'mark': 'AROUND'},
     \ 'file': {'mark': 'FILE'},
     \ 'nvim-lsp': {
     \   'mark': 'LSP',
     \   'dup': 'keep',
     \   'keywordPattern': '\k+',
     \   'sorters': ['sorter_lsp-kind']
     \ },
\})

call ddc#custom#patch_global('sourceParams', {
\  'around': {'maxSize': 500},
\  'nvim-lsp': {
\    'snippetEngine': denops#callback#register({
\          body -> vsnip#anonymous(body) }),
\    'enableResolveItem': v:true,
\    'enableAdditionalTextEdit': v:true,
\    'confirmBehavior': 'replace',
\  },
\})

call ddc#enable()
'''
# # LSPの補完開始を遅くする設定(主にTerraformのresource補完用)
# hook_add = '''
# nnoremap <silent> gcl :call ddc#custom#patch_global('sourceOptions', {'nvim-lsp': {'minAutoCompleteLength': 5}})<CR>
# nnoremap <silent> gcs :call ddc#custom#patch_global('sourceOptions', {'nvim-lsp': {'minAutoCompleteLength': 1}})<CR>

[[plugins]]
repo = 'Shougo/ddc-ui-pum'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-source-nvim-lsp'
on_source = 'ddc.vim'

[[plugins]]
repo = 'uga-rosa/ddc-nvim-lsp-setup'
on_source = 'ddc.vim'
hook_source = '''
lua << EOF
require("ddc_nvim_lsp_setup").setup()
EOF
'''

[[plugins]]
repo = 'tani/ddc-fuzzy'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-source-around'
on_source = 'ddc.vim'

# ファイル名を補完するsource
[[plugins]]
repo = 'LumaKernel/ddc-source-file'
on_source = 'ddc.vim'

# ポップアップウィンドウを表示するプラグイン
[[plugins]]
repo = 'Shougo/pum.vim'
# on_source = 'ddc.vim'
# depends = ['vim-vsnip-integ']
# <Tab>と<S-Tab>が何故か効かないのでいっそのことコメントアウトしている.
hook_add = '''
" "inoremap <Tab> <Cmd>call pum#map#insert_relative(+1)<CR>
" "inoremap <S-Tab> <Cmd>call pum#map#insert_relative(-1)<CR>
" "inoremap <silent><expr> <TAB>
" "     \ pum#visible() ? '<Cmd>call pum#map#insert_relative(+1)<CR>' :
" "     \ (col('.') <= 1 <Bar><Bar> getline('.')[col('.') - 2] =~# '\s') ?
" "     \ '<TAB>' : ddc#manual_complete()
" "inoremap <S-Tab> <Cmd>call pum#map#insert_relative(-1)<CR>
inoremap <C-n>   <Cmd>call pum#map#insert_relative(+1)<CR>
inoremap <C-p>   <Cmd>call pum#map#insert_relative(-1)<CR>

" autocmd User PumCompleteDone call vsnip_integ#on_complete_done(g:pum#completed_item)
'''



# # [[plugins]] # TODO: 削除する.
# # # インストール済みのlinterやforatterを呼び出しての出力結果をLSPに渡す
# # repo ='jose-elias-alvarez/null-ls.nvim'
# # depends = ['plenary.nvim']
# # on_source = 'nvim-lspconfig'
# # hook_source = '''
# # lua << EOF
# # require("null-ls").setup({
# #     sources = {
# #         -- require("null-ls").builtins.completion.spell,
# #         require("null-ls").builtins.diagnostics.flake8,
# #         require("null-ls").builtins.diagnostics.mypy,
# #         require("null-ls").builtins.diagnostics.shellcheck,
# #         require("null-ls").builtins.diagnostics.cfn_lint,
# #         require("null-ls").builtins.formatting.ruff,
# #         require("null-ls").builtins.diagnostics.ruff,
# #         -- require("null-ls").builtins.diagnostics.mypy.with({
# #         --     command = "pipenv run mypy",
# #         -- }),
# #     }
# # })
# # EOF
# # '''

[[plugins]]
# LSPの動作待ち中プログレスバーを表示する.
# 下記エラーが表示されるようになったのでとりあえず外した.
# fidget.nvim will soon be rewritten. Please checkout the 'legacy' tag to avoid breaking changes
# -> 2023/11/01ではlegacy固定にする必要がある. # TODO: 定期的にバグが取り除かれたかチェックする.
repo = 'j-hui/fidget.nvim'
rev = "legacy"
on_event = 'BufEnter'
hook_source = '''
lua require"fidget".setup{}
'''

# ddcの候補選択中にシグネイチャーとドキュメントをポップアップする.
[[plugins]]
repo = 'matsui54/denops-popup-preview.vim'
on_source = 'ddc.vim'
depends = ['denops.vim']
hook_source = '''
call popup_preview#enable()
'''

# 関数の()内入力中にシグネイチャーをポップアップする.
# ddcやdenops-popup-preview.vimとは独立して動く.
[[plugins]]
repo = 'ray-x/lsp_signature.nvim'
on_event = 'BufRead'
hook_source = '''
lua << EOF
require("lsp_signature").setup()
EOF
 '''

[[plugins]]
# diagnosticsの一覧を表示する.diagnosticsの発生個所に飛べる.
# 一覧にカーソルを合わせるだけで発生個所が表示されるので、
# LSPのショートカットキーで一つずつ飛ぶより楽.
# 実行コマンド :TroubleToggle
# 実行コマンド :TroubleRefresh
repo = 'folke/trouble.nvim'
depends = ['nvim-web-devicons']
on_event = 'BufRead'
hook_source = '''
lua << EOF
require("trouble").setup {}
-- vim.keymap.set("n", "<leader>gxd", function() require("trouble").toggle("document_diagnostics") end)
vim.keymap.set("n", "gX", function() require("trouble").toggle("workspace_diagnostics") end)
EOF
'''


# [[plugins]] # TODO: 更新対応.
#  repo = 'hrsh7th/vim-vsnip'
#  on_event = 'InsertEnter'
#  depends = ['vim-vsnip-integ']
#  hook_add = '''
#  " Expand
#  imap <expr> <C-j>   vsnip#expandable()  ? '<Plug>(vsnip-expand)'         : '<C-j>'
#  smap <expr> <C-j>   vsnip#expandable()  ? '<Plug>(vsnip-expand)'         : '<C-j>'
#  
#  " Expand or jump
#  imap <expr> <C-l>   vsnip#available(1)  ? '<Plug>(vsnip-expand-or-jump)' : '<C-l>'
#  smap <expr> <C-l>   vsnip#available(1)  ? '<Plug>(vsnip-expand-or-jump)' : '<C-l>'
#  
#  " Jump forward or backward
#  imap <expr> <Tab>   vsnip#jumpable(1)   ? '<Plug>(vsnip-jump-next)'      : '<Tab>'
#  smap <expr> <Tab>   vsnip#jumpable(1)   ? '<Plug>(vsnip-jump-next)'      : '<Tab>'
#  imap <expr> <S-Tab> vsnip#jumpable(-1)  ? '<Plug>(vsnip-jump-prev)'      : '<S-Tab>'
#  smap <expr> <S-Tab> vsnip#jumpable(-1)  ? '<Plug>(vsnip-jump-prev)'      : '<S-Tab>'
#  
#  " " Select or cut text to use as $TM_SELECTED_TEXT in the next snippet.
#  " " See https://github.com/hrsh7th/vim-vsnip/pull/50
#  " nmap        s   <Plug>(vsnip-select-text)
#  " xmap        s   <Plug>(vsnip-select-text)
#  " nmap        S   <Plug>(vsnip-cut-text)
#  " xmap        S   <Plug>(vsnip-cut-text)
#  
#  " If you want to use snippet for multiple filetypes, you can `g:vsnip_filetypes` for it.
#  let g:vsnip_filetypes = {}
#  let g:vsnip_filetypes.python = ['python']
#  " let g:vsnip_filetypes.javascriptreact = ['javascript']
#  " let g:vsnip_filetypes.typescriptreact = ['typescript']
# 
#  " let g:vsnip_snippet_dir = expand('~/.config/nvim/vsnips')
#  let g:vsnip_snippet_dirs = []
#  let g:vsnip_snippet_dirs += ['~/.config/nvim/vsnips/python']
#  let g:vsnip_snippet_dirs += ['~/.config/nvim/vsnips/python/pytest']
#  let g:vsnip_snippet_dirs += ['~/.config/nvim/vsnips/terraform']
#  '''


# # ---------------------------------------------------------------------------------------------
# # デバッグツール.
# # ---------------------------------------------------------------------------------------------
# [[plugins]]
# # デバッグツール
# # ステップイン: 1行進む.
# # ステップオーバー: 1行進む.進み先が関数内に入る場合は、関数内はスキップする.
# # ステップアウト: そのスコープを出るまで進む.
# repo = 'mfussenegger/nvim-dap'
# on_ft = ['python']
# hook_add = '''
# nnoremap <silent> <Leader>0 :lua require'dap'.continue()<CR>
# nnoremap <silent> <Leader>1 :lua require'dap'.step_into()<CR>
# nnoremap <silent> <Leader>2 :lua require'dap'.step_over()<CR>
# nnoremap <silent> <Leader>3 :lua require'dap'.step_out()<CR>
# nnoremap <silent> <leader>dq :lua require'dap'.terminate(); require'dapui'.close()<CR>
# nnoremap <silent> <leader>db :lua require'dap'.toggle_breakpoint()<CR>
# nnoremap <silent> <leader>dc :lua require'dap'.set_breakpoint(vim.fn.input('Breakpoint condition: '))<CR>
# nnoremap <silent> <leader>dB :lua require'dap'.clear_breakpoints()<CR>
# " nnoremap <silent> <leader>dp :lua require'dap'.set_breakpoint(nil, nil, vim.fn.input('Log point message: '))<CR>
# " nnoremap <silent> <leader>dr :lua require'dap'.repl.open()<CR>
# '''
# 
# [[plugins]]
# # 
# repo = 'mfussenegger/nvim-dap-python'
# depends = ['nvim-dap']
# on_ft = 'python'
# hook_source = '''
# lua << EOF
# pythonPath = function()
#   -- debugpy supports launching an application with a different interpreter then the one used to launch debugpy itself.
#   -- The code below looks for a `venv` or `.venv` folder in the current directly and uses the python within.
#   -- You could adapt this - to for example use the `VIRTUAL_ENV` environment variable.
#   local cwd = vim.fn.getcwd()
#   if vim.fn.executable(cwd .. '/venv/bin/python') == 1 then
#     return cwd .. '/venv/bin/python'
#   elseif vim.fn.executable(cwd .. '/.venv/bin/python') == 1 then
#     return cwd .. '/.venv/bin/python'
#   else
#     return '/usr/bin/python'
#   end
# end;
# 
# require('dap-python').setup(pythonPath())
# require('dap-python').test_runner = 'pytest'
# EOF
# '''
# 
# [[plugins]]
# # デバッグツール
# # デバッグ画面
# repo = 'rcarriga/nvim-dap-ui'
# # depends = ['nvim-dap']
# # on_ft = ['python']
# on_source = ['nvim-dap']
# hook_source = '''
# lua << EOF
# require('dapui').setup()
# 
# -- デバッグ開始時に自動でUI画面を開く.
# require'dap'.listeners.before['event_initialized']['custom'] = function(session, body)
#   require'dapui'.open()
# end
# -- デバッグ終了時に自動でUI画面を閉じる.
# require'dap'.listeners.before['event_terminated']['custom'] = function(session, body)
#   require'dapui'.close()
# end
# EOF
# '''
# 
# [[plugins]]
# # デバッグツール
# # 変数の値をvertualtextで表示する
# repo = 'theHamsta/nvim-dap-virtual-text'
# # depends = ['nvim-dap']
# on_ft = ['python']
# hook_source = '''
# lua << EOF
# -- require("nvim-dap-virtual-text").setup()
# require("nvim-dap-virtual-text").setup {
#     enabled = true,                     -- enable this plugin (the default)
#     enabled_commands = true,            -- create commands DapVirtualTextEnable, DapVirtualTextDisable, DapVirtualTextToggle, (DapVirtualTextForceRefresh for refreshing when debug adapter did not notify its termination)
#     highlight_changed_variables = false, -- highlight changed values with NvimDapVirtualTextChanged, else always NvimDapVirtualText
#     highlight_new_as_changed = false,   -- highlight new variables in the same way as changed variables (if highlight_changed_variables)
#     show_stop_reason = true,            -- show stop reason when stopped for exceptions
#     commented = false,                  -- prefix virtual text with comment string
#     -- experimental features:
#     virt_text_pos = 'eol',              -- position of virtual text, see `:h nvim_buf_set_extmark()`
#     all_frames = false,                 -- show virtual text for all stack frames not only current. Only works for debugpy on my machine.
#     virt_lines = false,                 -- show virtual lines instead of virtual text (will flicker!)
#     virt_text_win_col = nil             -- position the virtual text at a fixed window column (starting from the first text column) ,
#                                         -- e.g. 80 to position at column 80, see `:h nvim_buf_set_extmark()`
# }
# EOF
# '''



# ---------------------------------------------------------------------------------------------
# ファジーファインダー系
# ---------------------------------------------------------------------------------------------

[[plugins]]
# Reference: https://zenn.dev/vim_jp/articles/c0d75d1f3c7f33
# 使用の流れ.
# No  目的                            実際の操作
# 1   ddu.vimで一覧を表示する         :call ddu#start({オプション})
# 2   Input用のバッファを表示する     :call ddu#ui#do_action("openFilterWindow")
# 3   Itemを絞り込むワードを入力する  i キーワードを入力 <ESC>
# 4   一覧のバッファに移動する        :call ddu#ui#do_action("leaveFilterWindow")
# 5   Itemを選ぶ                      j や k で移動する
# 6   Kindのアクションを呼び出す      :call ddu#ui#do_action("itemAction", {"name": {アクション名}})
# 
repo = 'Shougo/ddu.vim'
on_event = 'BufEnter'
depends = ['denops.vim']
# hook_source = '''
# call ddu#custom#patch_global({
#     \     "ui": "ff",
#     \     "sourceOptions": {
#     \         "_": {
#     \             "matchers": ["matcher_substring"]
#     \         },
#     \     },
#     \ })
# 
# " DduNodeFilesで使用する設定を用意する
# call ddu#custom#patch_local("node-files", {
#     \     "sources": ["file_rec"],
#     \     "sourceParams": {
#     \         "file_rec": {
#     \             "ignoredDirectories": [".git", "node_modules"],
#     \         }
#     \     }
#     \ })
# 
# " DduWholeFilesで使用する設定を用意する
# call ddu#custom#patch_local("whole-files", {
#     \     "sources": ["file_rec"],
#     \     "sourceParams": {
#     \         "file_rec": {
#     \             "ignoredDirectories": [],
#     \         }
#     \     },
#     \     "sourceOptions": {
#     \         "file_rec": {
#     \             "maxItems": 50000
#     \         }
#     \     }
#     \ })
# 
# " ddu-ui-ff上でのみ有効なKeymap（`e`）を設定する
# autocmd FileType ddu-ff call s:ddu_ff_settings()
# function s:ddu_ff_settings() abort
#     nnoremap <buffer> e <Cmd>call ddu#ui#do_action('itemAction', {'name': 'open'})<CR>
# endfunction
# 
# " ddu#startを各オプションセット名で呼び出すコマンドを準備する
# command! DduNodeFiles call ddu#start({"name": "node-files", "sourceOptions": {"file_rec": {"path": getcwd()}}})
# command! DduWholeFiles call ddu#start({"name": "whole-files", "sourceOptions": {"file_rec": {"path": getcwd()}}})
# '''

# hook_source = '''
# lua << EOF
# --  config = function()
#     vim.fn["ddu#custom#patch_global"]({
#         ui = "ff",
#         uiParams = {
#           ff = {
#             filterFloatingPosition = "bottom",
#             filterSplitDirection = "floating",
#             floatingBorder = "rounded",
#             previewFloating = true,
#             previewFloatingBorder = "rounded",
#             previewFloatingTitle = "Preview",
#             previewSplit = "horizontal",
#             prompt = "> ",
#             split = "floating",
#             startFilter = true,
#           }
#         },
#         sourceOptions = {
#           _ = {
#             matchers = {
#               "matcher_substring",
#             },
#             ignoreCase = true,
#           },
#         },
#       })
#     vim.fn["ddu#custom#patch_local"]("file_recursive", {
#         sources = {
#           {
#             name = { "file_rec" },
#             options = {
#               converters = {
#                 "converter_devicon",
#               },
#             },
#             params = {
#               ignoredDirectories = { "node_modules", ".git", "dist", ".vscode" },
#             },
#           },
#         },
#         kindOptions = {
#           file = {
#             defaultAction = "open",
#           }
#         }
#       })
#     -- vim.fn["ddu#custom#patch_local"]("colorscheme", {
#     --     sources = {
#     --       {
#     --         name = { "colorscheme" },
#     --       },
#     --     },
#     --     kindOptions = {
#     --       colorscheme = {
#     --         defaultAction = "set",
#     --       }
#     --     }
#     --   })
# 
#     vim.api.nvim_create_autocmd("FileType",{
#         pattern = "ddu-ff",
#         callback = function()
#           local opts = { noremap = true, silent = true, buffer = true }
#           vim.keymap.set({ "n" }, "q", [[<Cmd>call ddu#ui#ff#do_action("quit")<CR>]], opts)
#           vim.keymap.set({ "n" }, "<Cr>", [[<Cmd>call ddu#ui#ff#do_action("itemAction")<CR>]], opts)
#           vim.keymap.set({ "n" }, "i", [[<Cmd>call ddu#ui#ff#do_action("openFilterWindow")<CR>]], opts)
#           vim.keymap.set({ "n" }, "P", [[<Cmd>call ddu#ui#ff#do_action("togglePreview")<CR>]], opts)
#         end,
#       }
#       )
# 
#     vim.api.nvim_create_autocmd("FileType",{
#         pattern = "ddu-ff-filter",
#         callback = function()
#           local opts = { noremap = true, silent = true, buffer = true }
#           vim.keymap.set({ "n", "i" }, "<CR>", [[<Esc><Cmd>close<CR>]], opts)
#         end,
#       }
#       )
# --  end,
# EOF
# '''

hook_source = '''
" # --------------------------------------------------------------------------
" # ddu-ffの共通キーバインド設定.
" # --------------------------------------------------------------------------

" ddu-ffのitem表示ウィンドウ上にいる時のキーバインド.
autocmd FileType ddu-ff call s:on_ddu_ff_item_window()
function! s:on_ddu_ff_item_window() abort
  " Enterでアイテムのデフォルトアクション実行.
  " アイテム未選択ならカーソル下のアイテムが対象.
  nnoremap <buffer><silent> <CR>
        \ <Cmd>call ddu#ui#ff#do_action('itemAction')<CR>

  " iでカーソル下のアイテムの選択状態切り替え.
  nnoremap <buffer><silent> i
        \ <Cmd>call ddu#ui#ff#do_action('toggleSelectItem')<CR>

  " fでFilterWindowをもう一度開く.(itemウィンドウかPreviewで利用する)
  nnoremap <buffer><silent> f
        \ <Cmd>call ddu#ui#ff#do_action('openFilterWindow')<CR>

  " qでdduを閉じる.
  nnoremap <buffer><silent> q
        \ <Cmd>call ddu#ui#ff#do_action('quit')<CR>

  " ESCでdduを閉じる.
  nnoremap <buffer><silent> <ESC>
        \ <Cmd>call ddu#ui#ff#do_action('quit')<CR>
endfunction

" ddu-ffのフィルターウィンドウ上でのキーバインド.
autocmd FileType ddu-ff-filter call s:on_ddu_ff_filter_window()
function! s:on_ddu_ff_filter_window() abort
  " インサートモード中にEnterでFilterWindowを一旦閉じてitem選択Windowに遷移する.
  " 入力していた文字列はFilterWindowをitem選択Windowから再度FilterWindowを開いた際に残っている.
  " itemウィンドウを操作する為にnormalモードに戻しておく.
  inoremap <buffer><silent> <CR>
        \ <Esc><Cmd>call ddu#ui#ff#do_action("closeFilterWindow")<CR>

  " qでdduを閉じる.
  nnoremap <buffer><silent> q
        \ <Cmd>call ddu#ui#ff#do_action('quit')<CR>

  " ESCでdduを閉じる.
  nnoremap <buffer><silent> <ESC>
        \ <Cmd>call ddu#ui#ff#do_action('quit')<CR>

endfunction


" # --------------------------------------------------------------------------
" # LSP.
" # カーソル下のwordの定義ジャンプ(definition).
" # --------------------------------------------------------------------------

" command! DduLspDefinition call ddu#start({
"     \ "sync": v:true,
"     \ "sources": [{
"     \   "name": 'lsp_definition',
"     \ }],
"     \ "uiParams": {
"     \   "ff": {
"     \     "immediateAction": 'open',
"     \   },
"     \ }
"     \})


" # --------------------------------------------------------------------------
" # LSP.
" # カーソル下のwordの参照ジャンプ(reference).
" # --------------------------------------------------------------------------

lua << EOF
local function resize()
  local lines = vim.opt.lines:get()
  local height, row = math.floor(lines * 0.95), math.floor(lines * 0.01)
  local columns = vim.opt.columns:get()
  local width, col = math.floor(columns * 0.49), math.floor(columns * 0.01)
  local previewWidth = width
  local previewCol = col + 0.01

  vim.fn["ddu#custom#patch_local"]("lsp_reference_on_word", {
    uiParams = {
      ff = {
        winHeight = height,
        winRow = row,
        winWidth = width,
        winCol = col,
        previewHeight = height,
        previewRow = row,
        previewWidth = previewWidth,
        previewCol = previewCol,
      },
    },
  })
end
resize()

vim.api.nvim_create_autocmd("VimResized", {
  callback = resize,
})
EOF

command! DduLspReferences call ddu#start({
    \ "name": "lsp_reference_on_word",
    \ "ui": "ff",
    \ "sync": v:true,
    \ "sources": [{
    \   "name": 'lsp_references',
    \   "params": {"includeDeclaration": v:false},
    \ }],
    \ "kindOptions": {
    \   "lsp": {
    \     "defaultAction": 'open',
    \   },
    \ },
    \ "uiParams": {
    \   "ff": {
    \     "displaySourceName": "no",
    \     "startFilter": v:false,
    \     "split": "floating",
    \     "floatingBorder": "rounded",
    \     "filterFloatingPosition": "top",
    \     "filterFloatingTitle": "Filter01",
    \     "autoAction": {
    \       "name": "preview",
    \     },
    \     "startAutoAction": v:true,
    \     "previewFloating": v:true,
    \     "previewFloatingBorder": "double",
    \     "previewSplit": "vertical",
    \     "previewFloatingTitle": "CodePreview",
    \     "previewWindowOptions": [
    \       [ "&signcolumn", "no" ],
    \       [ "&foldcolumn", 0 ],
    \       [ "&foldenable", 0 ],
    \       [ "&number", 1 ],
    \       [ "&wrap", 0 ],
    \       [ "&scrolloff", 1 ],
    \     ],
    \     "highlights": {
    \       "floating": "Normal",
    \       "floatingBorder": "Normal",
    \     },
    \   },
    \ }
    \})

nnoremap <buffer><silent>gr :DduLspReferences<CR>


" " # --------------------------------------------------------------------------
" " # LSP.
" " # 現在のバッファ内のシンボル一覧(documentSymbol).
" " # --------------------------------------------------------------------------
" 
" lua << EOF
" local function resize()
"   local lines = vim.opt.lines:get()
"   local height, row = math.floor(lines * 0.95), math.floor(lines * 0.01)
"   local columns = vim.opt.columns:get()
"   local width, col = math.floor(columns * 0.49), math.floor(columns * 0.01)
"   local previewWidth = width
"   local previewCol = col + 0.01
" 
"   vim.fn["ddu#custom#patch_local"]("lsp_documentSymbol_in_buffer", {
"     uiParams = {
"       ff = {
"         winHeight = height,
"         winRow = row,
"         winWidth = width,
"         winCol = col,
"         previewHeight = height,
"         previewRow = row,
"         previewWidth = previewWidth,
"         previewCol = previewCol,
"       },
"     },
"   })
" end
" resize()
" 
" vim.api.nvim_create_autocmd("VimResized", {
"   callback = resize,
" })
" EOF
" 
" command! DduLspDucmentSymbol call ddu#start({
"     \ "name": "lsp_documentSymbol_in_buffer",
"     \ "ui": "ff",
"     \ "sources": [{
"     \   "name": 'lsp_documentSymbol',
"     \   "options": {
"     \     "converters": [
"     \       {
"     \         "name": "converter_lsp_symbol",
"     \       },
"     \     ],
"     \   },
"     \ }],
"     \ "kindOptions": {
"     \   "lsp": {
"     \     "defaultAction": 'open',
"     \   },
"     \ },
"     \ "uiParams": {
"     \   "ff": {
"     \     "displaySourceName": "no",
"     \     "startFilter": v:false,
"     \     "split": "floating",
"     \     "floatingBorder": "rounded",
"     \     "filterFloatingPosition": "top",
"     \     "filterFloatingTitle": "Filter01",
"     \     "autoAction": {
"     \       "name": "preview",
"     \     },
"     \     "startAutoAction": v:true,
"     \     "previewFloating": v:true,
"     \     "previewFloatingBorder": "double",
"     \     "previewSplit": "vertical",
"     \     "previewFloatingTitle": "CodePreview",
"     \     "previewWindowOptions": [
"     \       [ "&signcolumn", "no" ],
"     \       [ "&foldcolumn", 0 ],
"     \       [ "&foldenable", 0 ],
"     \       [ "&number", 1 ],
"     \       [ "&wrap", 0 ],
"     \       [ "&scrolloff", 1 ],
"     \     ],
"     \     "highlights": {
"     \       "floating": "Normal",
"     \       "floatingBorder": "Normal",
"     \     },
"     \   },
"     \ }
"     \})
" 
" nnoremap <buffer><silent>gS :DduLspDucmentSymbol<CR>

" # --------------------------------------------------------------------------
" # LSP.
" # 警告一覧(diagnostic).
" # linter名を表示できない為、trouble.nvimを利用する.
" # --------------------------------------------------------------------------

" command! DduLspDiagnostic call ddu#start({
"     \ "ui": "ff",
"     \ "sync": v:true,
"     \ "sourceOptions": {
"     \   "_": {
"     \     "converters": [
"     \        {
"     \          "name": "converter_lsp_diagnostic",
"     \          "params": {
"     \            "iconMap": {
"     \              "Error": "E",
"     \              "Warning": "W",
"     \              "Info": "I",
"     \              "Hint": "H",
"     \            },
"     \            "columnLength": 100,
"     \          },
"     \        },
"     \      ],
"     \   },
"     \ },
"     \ "sources": [{
"     \   "name": 'lsp_diagnostic',
"     \   "params": { "buffer": v:null, },
"     \ }],
"     \ "uiParams": {
"     \   "ff": {
"     \     "immediateAction": 'open',
"     \     "startFilter": v:false,
"     \   },
"     \  },
"     \})
" "     \ "sourceOptions": {
" "     \   "_": {
" "     \     "converters": ["converter_lsp_diagnostic"],
" "     \   },
" "     \ },
" "     \ "FilterParams": {
" "     \   "converter_lsp_diagnostic": {
" "     \     "IconMap": {
" "     \       "Warning": "b",
" "     \     },
" "     \   },
" "     \ },


" # --------------------------------------------------------------------------
" # LSP.
" # 作業リポジトリ全体のシンボル一覧(workspaceSymbol).
" # Not work on pylsp.
" # --------------------------------------------------------------------------

" command! DduLspWorkspaceSymbol call ddu#start({
"     \ "ui": "ff",
"     \ "sources": [{
"     \   "name": 'lsp_workspaceSymbol',
"     \ }],
"     \ "sourceOptions": {
"     \   "lsp": {
"     \     "volatile": v:true,
"     \   },
"     \ },
"     \ "uiParams": {
"     \   "ff": {
"     \     "ignoreEmpty": v:false,
"     \     "displayTree": v:true,
"     \   },
"     \ }
"     \})


" # --------------------------------------------------------------------------
" # LSP.
" # 
" # --------------------------------------------------------------------------

" " Not work on pylsp.
" command! DduLspCallHierarchy call ddu#start({
"     \ "sources": [{
"     \   "name": 'lsp_callHierarchy',
"     \   "params": {
"     \     "method": 'callHierarchy/outgoingCalls',
"     \   }
"     \ }],
"     \ "uiParams": {
"     \   "ff": {
"     \     "displayTree": v:true,
"     \     "startFilter": v:false,
"     \   },
"     \ }
"     \})


" # --------------------------------------------------------------------------
" # ファイルあいまい検索.
" # --------------------------------------------------------------------------

lua << EOF
local function resize()
  local lines = vim.opt.lines:get()
  local height, row = math.floor(lines * 0.85), math.floor(lines * 0.1)
  local columns = vim.opt.columns:get()
  local width, col = math.floor(columns * 0.49), math.floor(columns * 0.01)
  local previewWidth = width
  local previewCol = col + width + 0.01

  vim.fn["ddu#custom#patch_local"]("find_file_by_ff", {
    uiParams = {
      ff = {
        winHeight = height,
        winRow = row,
        winWidth = width,
        winCol = col,
        previewHeight = height,
        previewRow = row,
        previewWidth = previewWidth,
        previewCol = previewCol,
      },
    },
  })
end
resize()

vim.api.nvim_create_autocmd("VimResized", {
  callback = resize,
})
EOF

command! DduOpenFile call ddu#start({
    \ "name": "find_file_by_ff",
    \ "ui": "ff",
    \ "sync": v:true,
    \ "sources": [
    \   {
    \     "name": 'file_rec',
    \     "params": {
    \       "ignoredDirectories": [".git", ".venv", ".mypy_cache", ".ruff_cache"],
    \     },
    \   },
    \ ],
    \ "sourceOptions": {
    \   "file_rec": {
    \     "columns": ['icon_filename'],
    \     'matchers': ['matcher_substring'],
    \   },
    \ },
    \ "columnParams": {
    \   "icon_filename": {
    \     "pathDisplayOption": "relative"
    \   },
    \ },
    \ "kindOptions": {
    \   "file": {
    \     "defaultAction": 'open',
    \   },
    \ },
    \ 'filterParams': {
    \   'matcher_substring': {
    \     'highlightMatched': 'Search',
    \   },
    \ },
    \ "uiParams": {
    \   "ff": {
    \     "prompt": "> ",
    \     "startFilter": v:true,
    \     "displaySourceName": "no",
    \     "split": "floating",
    \     "floatingBorder": "rounded",
    \     "filterFloatingPosition": "top",
    \     "filterFloatingTitle": "Filter01",
    \     "autoAction": {
    \       "name": "preview",
    \     },
    \     "startAutoAction": v:true,
    \     "previewFloating": v:true,
    \     "previewFloatingBorder": "double",
    \     "previewSplit": "vertical",
    \     "previewFloatingTitle": "CodePreview",
    \     "previewWindowOptions": [
    \       [ "&signcolumn", "no" ],
    \       [ "&foldcolumn", 0 ],
    \       [ "&foldenable", 0 ],
    \       [ "&number", 1 ],
    \       [ "&wrap", 0 ],
    \       [ "&scrolloff", 1 ],
    \     ],
    \     "highlights": {
    \       "floating": "Normal",
    \       "floatingBorder": "Normal",
    \     },
    \   },
    \ }
    \})

nnoremap <Leader>ff :DduOpenFile<CR>


" # --------------------------------------------------------------------------
" # ファイラー.
" # --------------------------------------------------------------------------

" 定期的にアイテム更新.
autocmd TabEnter,CursorHold,FocusGained <buffer>
	\ call ddu#ui#filer#do_action('checkItems')

" ファイラー上のキーマッピング
autocmd FileType ddu-filer call s:ddu_filer_my_settings()
function! s:ddu_filer_my_settings() abort

  " ファイルの上でEnter or v: 右側に開く(ファイラーは閉じる)
  nnoremap <buffer><silent><expr> <CR>
    \ ddu#ui#get_item()->get('isTree', v:false) ?
    \ "<Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'narrow'})<CR>" :
    \ "<Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'open', 'params': {'command': 'vsplit'}})<CR>"

  " ファイルの上でEnter or v: 右側に開く(ファイラーは閉じる)
  nnoremap <buffer><silent><expr> v
    \ ddu#ui#get_item()->get('isTree', v:false) ?
    \ "<Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'narrow'})<CR>" :
    \ "<Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'open', 'params': {'command': 'vsplit'}})<CR>"

  " ファイルの上でe: 既に開いているウィンドウ上に開く.(ファイラーは閉じる)
  nnoremap <buffer><silent><expr> e
    \ ddu#ui#get_item()->get('isTree', v:false) ?
    \ "<Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'narrow'})<CR>" :
    \ "<Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'open', 'params': {'command': 'split'}})<CR>"

  " ディレクトリ上でo: ディレクトリを開く.
  nnoremap <buffer> o
        \ <Cmd>call ddu#ui#filer#do_action('expandItem',
        \ {'mode': 'toggle'})<CR>

  " q or <ESC>: filerを閉じる
  nnoremap <buffer><silent> <Esc>
    \ <Cmd>call ddu#ui#filer#do_action('quit')<CR>

  " q or <ESC>: filerを閉じる
  nnoremap <buffer><silent> q
    \ <Cmd>call ddu#ui#filer#do_action('quit')<CR>


"   " キーマッピングを覚えられないから一旦消しておく.
"   nnoremap <buffer><silent> <Space>
"         \ <Cmd>call ddu#ui#filer#do_action('toggleSelectItem')<CR>
" 
"   nnoremap <buffer><silent> ..
"     \ <Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'narrow', 'params': {'path': '..'}})<CR>
" 
"   nnoremap <buffer><silent> c
"     \ <Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'copy'})<CR>
" 
"   nnoremap <buffer><silent> p
"     \ <Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'paste'})<CR>
" 
"   nnoremap <buffer><silent> d
"     \ <Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'delete'})<CR>
" 
"   nnoremap <buffer><silent> r
"     \ <Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'rename'})<CR>
" 
"   nnoremap <buffer><silent> mv
"     \ <Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'move'})<CR>
" 
"   nnoremap <buffer><silent> t
"     \ <Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'newFile'})<CR>
" 
"   nnoremap <buffer><silent> mk
"     \ <Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'newDirectory'})<CR>
" 
"   nnoremap <buffer><silent> yy
"     \ <Cmd>call ddu#ui#filer#do_action('itemAction', {'name': 'yank'})<CR>
endfunction

command! DduOpenFiler call ddu#start({
\   'name': 'filer',
\   'ui': 'filer',
\   'sources': ['file'],
\   "sourceOptions": {
\     "file": {
\       "columns": ['icon_filename'],
\       "converters": ["converter_hl_dir"],
\     },
\   },
\   'kindOptions': {
\     'file': {
\       'defaultAction': 'open',
\     },
\   },
\   'uiParams': {
\     'filer': {
\       'winWidth': 40,
\       'split': 'vertical',
\       'splitDirection': 'topleft',
\       'sort': 'filename',
\       'sortTreeFirst': v:true,
\     }
\   },
\   "searchPath": expand("%:p"),
\ })

" \   "columnParams": {
" \     "icon_filename": {
" \       "pathDisplayOption": "relative",
" \     },
" \   },

" command! DduOpenFiler call ddu#start({
" \   'name': 'filer',
" \   'ui': 'filer',
" \   'sources': [
" \     {
" \       "name": 'file_external',
" \       "params": {
" \         "cmd": ["fd", ".", "-tf"],
" \       },
" \     },
" \   ],
" \   "sourceOptions": {
" \     "file_external": {
" \       "columns": ['icon_filename'],
" \       "converters": ["converter_hl_dir"],
" \     },
" \   },
" \   'kindOptions': {
" \     'file': {
" \       'defaultAction': 'open',
" \     },
" \   },
" \   'uiParams': {
" \     'filer': {
" \       'winWidth': 100,
" \       'split': 'vertical',
" \       'toggle': v:true,
" \       'splitDirection': 'topleft',
" \       'sort': 'filename',
" \       'sortTreeFirst': v:true,
" \     }
" \   },
" \   "searchPath": expand("%:p"),
" \ })

nnoremap <Leader>ft :DduOpenFiler<CR>

" # --------------------------------------------------------------------------
" # バッファ読み込み.
" # --------------------------------------------------------------------------

lua << EOF
local function resize()
  local lines = vim.opt.lines:get()
  local height, row = math.floor(lines * 0.95), math.floor(lines * 0.01)
  local columns = vim.opt.columns:get()
  local width, col = math.floor(columns * 0.49), math.floor(columns * 0.01)
  local previewWidth = width
  local previewCol = col + 0.01

  vim.fn["ddu#custom#patch_local"]("find_opening_buffer", {
    uiParams = {
      ff = {
        winHeight = height,
        winRow = row,
        winWidth = width,
        winCol = col,
        previewHeight = height,
        previewRow = row,
        previewWidth = previewWidth,
        previewCol = previewCol,
      },
    },
  })
end
resize()

vim.api.nvim_create_autocmd("VimResized", {
  callback = resize,
})
EOF

command! DduOpenBuffer call ddu#start({
    \ "name": "find_opening_buffer",
    \ "ui": "ff",
    \ "sources": ['buffer'],
    \ "sourceOptions": {
    \   "buffer": {
    \     "columns": ['icon_filename'],
    \   },
    \ },
    \ "columnParams": {
    \   "icon_filename": {
    \     "pathDisplayOption": "relative"
    \   },
    \ },
    \ "kindOptions": {
    \   "file": {
    \     "defaultAction": 'open',
    \   },
    \ },
    \ "uiParams": {
    \   "ff": {
    \     "displaySourceName": "no",
    \     "startFilter": v:false,
    \     "split": "floating",
    \     "floatingBorder": "rounded",
    \     "filterFloatingPosition": "top",
    \     "filterFloatingTitle": "Filter01",
    \     "autoAction": {
    \       "name": "preview",
    \     },
    \     "startAutoAction": v:true,
    \     "previewFloating": v:true,
    \     "previewFloatingBorder": "double",
    \     "previewSplit": "vertical",
    \     "previewFloatingTitle": "CodePreview",
    \     "previewWindowOptions": [
    \       [ "&signcolumn", "no" ],
    \       [ "&foldcolumn", 0 ],
    \       [ "&foldenable", 0 ],
    \       [ "&number", 1 ],
    \       [ "&wrap", 0 ],
    \       [ "&scrolloff", 1 ],
    \     ],
    \     "highlights": {
    \       "floating": "Normal",
    \       "floatingBorder": "Normal",
    \     },
    \   },
    \ }
    \})

nnoremap <Leader>fb :DduOpenBuffer<CR>

'''


[[plugins]]
# ファジーファインダー風のUI
repo = 'Shougo/ddu-ui-ff'
on_source = 'ddu.vim'

[[plugins]]
# ファイラー風のUI
repo = 'Shougo/ddu-ui-filer'
on_source = 'ddu.vim'

[[plugins]]
# ディレクトリ内のファイルを取得するsource
# itemがtreeに対応している..
repo = 'Shougo/ddu-source-file'
on_source = 'ddu.vim'

[[plugins]]
# ファイルを再帰的に取得するsource
# このsourceから取得されたitemはtreeに対応していない.
repo = 'Shougo/ddu-source-file_rec'
on_source = 'ddu.vim'

[[plugins]]
# 文字列,ファイル検索にripgrepを使用するsource
repo = 'shun/ddu-source-rg'
on_source = 'ddu.vim'

[[plugins]]
# fileのkindを持つsourceを外部コマンドで取得できる.
repo = 'matsui54/ddu-source-file_external'
on_source = 'ddu.vim'

[[plugins]]
# Openなどファイル関連の処理が定義されているkind
repo = 'Shougo/ddu-kind-file'
on_source = 'ddu.vim'

[[plugins]]
# Openなどファイル関連の処理が定義されているkind
repo = 'Shougo/ddu-source-dummy'
on_source = 'ddu.vim'

[[plugins]]
# 部分文字列への完全一致によってsourceを絞り込むfilter(matcher)
repo = 'Shougo/ddu-filter-matcher_substring'
on_source = 'ddu.vim'

[[plugins]]
# sourceのファイル名にnordfontのアイコンを付けるfilter(converter)
repo = 'uga-rosa/ddu-filter-converter_devicon'
on_source = 'ddu.vim'

[[plugins]]
# sourceファイルパスのディレクトリに色を付けるfilter(converter)
repo = 'kyoh86/ddu-filter-converter_hl_dir'
on_source = 'ddu.vim'

[[plugins]]
# LSPの情報を取得するsource
repo = 'uga-rosa/ddu-source-lsp'
on_source = 'ddu.vim'

[[plugins]]
# LSPの情報を取得するsource
repo = 'shun/ddu-source-buffer'
on_source = 'ddu.vim'


[[plugins]]
# iconとファイル名を表示するcolumn(ui-filer用)
repo = 'ryota2357/ddu-column-icon_filename'
on_source = 'ddu.vim'

# "4513ECHO/ddu-source-colorscheme",


# ---------------------------------------------------------------------------------------------
# プログラミング補助.
# Outline(Symbol)の表示.
# ---------------------------------------------------------------------------------------------

[[plugins]]
repo = 'stevearc/aerial.nvim'
on_event = 'BufEnter'
depends = ["nvim-treesitter"]
hook_source = '''
lua << EOF
-- Call the setup function to change the default behavior
require("aerial").setup({

  layout = {
    default_direction = "left",
  },
  -- When true, don't load aerial until a command or function is called
  -- Defaults to true, unless `on_attach` is provided, then it defaults to false
  lazy_load = true, -- TODO: 

  -- Highlight the closest symbol if the cursor is not exactly on one.
  highlight_closest = true,

  -- Highlight the symbol in the source buffer when cursor is in the aerial win
  highlight_on_hover = true,

  -- When jumping to a symbol, highlight the line for this many ms.
  -- Set to false to disable
  highlight_on_jump = 700,

  -- Jump to symbol in source window when the cursor moves
  autojump = false,

  -- When true, aerial will automatically close after jumping to a symbol
  close_on_select = true,

  -- Options for the floating nav windows
  nav = {
    border = "rounded",
    max_height = 30, -- 0.9,
    min_height = { 30, 0.1 },
    max_width = 20, -- 0.5,
    min_width = { 0.2, 20 },
    win_opts = {
      cursorline = true,
      winblend = 10,
    },
    -- Jump to symbol in source window when the cursor moves
    autojump = false,
    -- Show a preview of the code in the right column, when there are no child symbols
    preview = true,
    -- Keymaps in the nav window
    keymaps = {
      ["<CR>"] = "actions.jump",
      ["e"] = "actions.jump",
      ["v"] = "actions.jump_vsplit",
      ["s"] = "actions.jump_split",
      ["<C+h"] = "actions.left",
      ["h"] = "actions.left",
      ["<C+l"] = "actions.right",
      ["l"] = "actions.right",
      ["q"] = "actions.close",
      ["<Ecs>"] = "actions.close",
    },
  },

  lsp = {
    -- Fetch document symbols when LSP diagnostics update.
    -- If false, will update on buffer changes.
    diagnostics_trigger_update = false,

    -- Set to false to not update the symbols when there are LSP errors
    update_when_errors = false,

    -- How long to wait (in ms) after a buffer change before updating
    -- Only used when diagnostics_trigger_update = false
    update_delay = 30000,

    -- Map of LSP client name to priority. Default value is 10.
    -- Clients with higher (larger) priority will be used before those with lower priority.
    -- Set to -1 to never use the client.
    priority = {
      -- pyright = 10,
    },
  },

  treesitter = {
    -- How long to wait (in ms) after a buffer change before updating
    update_delay = 30000,
  },

  markdown = {
    -- How long to wait (in ms) after a buffer change before updating
    update_delay = 30000,
  },

  man = {
    -- How long to wait (in ms) after a buffer change before updating
    update_delay = 30000,
  },
})
vim.keymap.set("n", "go", "<cmd>AerialToggle!<CR>")
vim.keymap.set("n", "gO", "<cmd>AerialNavToggle<CR>")

EOF

hi link AerialClass Type
hi link AerialClassIcon Special
hi link AerialFunction Special
hi AerialFunctionIcon guifg=#cb4b16 guibg=NONE guisp=NONE gui=NONE cterm=NONE

" There's also this group for the fallback of the text if a specific
" class highlight isn't defined
hi link AerialNormal Normal
" There's also this group for the cursor position
hi link AerialLine QuickFixLine
" If highlight_mode="split_width", you can set a separate color for the
" non-current location highlight
hi AerialLineNC guibg=Gray

" You can customize the guides (if show_guide=true)
hi link AerialGuide Comment
" You can set a different guide color for each level
hi AerialGuide1 guifg=Red
hi AerialGuide2 guifg=Blue
'''

# ---------------------------------------------------------------------------------------------
# Git
# ---------------------------------------------------------------------------------------------

[[plugins]]
# 行の横に差分情報表示.
repo = 'lewis6991/gitsigns.nvim'
on_event = "BufEnter"
hook_source = '''
lua << EOF
-- provided default setting
require('gitsigns').setup {
  signs = {
    add          = { text = '│' },
    change       = { text = '│' },
    delete       = { text = '_' },
    topdelete    = { text = '‾' },
    changedelete = { text = '~' },
    untracked    = { text = '┆' },
  },
  signcolumn = true,  -- Toggle with `:Gitsigns toggle_signs`
  numhl      = false, -- Toggle with `:Gitsigns toggle_numhl`
  linehl     = false, -- Toggle with `:Gitsigns toggle_linehl`
  word_diff  = false, -- Toggle with `:Gitsigns toggle_word_diff`
  watch_gitdir = {
    follow_files = true
  },
  attach_to_untracked = true,
  current_line_blame = false, -- Toggle with `:Gitsigns toggle_current_line_blame`
  current_line_blame_opts = {
    virt_text = true,
    virt_text_pos = 'eol', -- 'eol' | 'overlay' | 'right_align'
    delay = 1000,
    ignore_whitespace = false,
    virt_text_priority = 100,
  },
  current_line_blame_formatter = '<author>, <author_time:%Y-%m-%d> - <summary>',
  sign_priority = 6,
  update_debounce = 100,
  status_formatter = nil, -- Use default
  max_file_length = 40000, -- Disable if file is longer than this (in lines)
  preview_config = {
    -- Options passed to nvim_open_win
    border = 'single',
    style = 'minimal',
    relative = 'cursor',
    row = 0,
    col = 1
  },
  yadm = {
    enable = false
  },
}
EOF

'''

